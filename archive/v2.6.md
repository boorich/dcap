# Dynamic Capability Acquisition Protocol (DCAP)

**Version**: 2.6  
**Date**: November 2025  
**Author**: M. Maurer  

## Abstract

This document defines the Dynamic Capability Acquisition Protocol (DCAP), a decentralized protocol enabling autonomous agents to discover, evaluate, and acquire computational capabilities at runtime through semantic broadcasting. DCAP uses UDP multicast for capability advertisement and WebSocket streams for real-time intelligence distribution.


## 1. Introduction

### 1.1 Problem Statement
Current autonomous agent systems operate with fixed, pre-configured tool sets, limiting their ability to handle novel or specialized tasks. Existing tool discovery mechanisms rely on centralized registries, creating bottlenecks and single points of failure. Additionally, discovered tools often lack sufficient connection metadata, making autonomous acquisition impractical.

### 1.2 Solution Overview
DCAP enables tools to self-advertise their capabilities using semantic descriptions, allowing agents to discover and dynamically load appropriate tools based on task requirements rather than static configuration. Version 2.6 significantly enhances the connector specification with comprehensive authentication details, required headers, and session initialization requirements, enabling truly autonomous tool acquisition.

## 2. Protocol Architecture

### 2.1 Network Topology
```
Tool Provider → UDP Broadcast → Intelligence Hub → WebSocket → Agent Consumer
     ^                              ^                   ^           ^
   MCP Tool                   Stream Aggregator    Real-time     Dynamic Agent
                                                                      ↓
                                                            Dynamic Tool Invocation
```

### 2.2 Transport Layers
- **Advertisement Layer**: UDP packets (port 10191)
- **Distribution Layer**: WebSocket streams 
- **Acquisition Layer**: MCP protocol over stdio/HTTP/SSE (specified in connector)

## 3. Message Format Specification

### 3.1 Base Message Structure
All DCAP messages MUST conform to this JSON schema:

```json
{
  "v": <protocol_version>,
  "t": <message_type>, 
  "ts": <unix_timestamp>,
  "sid": <server_identifier>,
  [message_specific_fields]
}
```

#### Required Fields:
- `v` (number): Protocol version (current: 2)
- `t` (string): Message type identifier
- `ts` (number): Unix timestamp of message creation
- `sid` (string): Unique server identifier (8-12 characters)

### 3.2 Message Types

#### 3.2.1 Semantic Discovery Message (`t: "semantic_discover"`)
Advertises tool capabilities using natural language descriptions with comprehensive connection information.

**Version 2.6 Update**: Significantly enhanced `connector` object with detailed authentication flows, required headers, session initialization, and credential acquisition instructions.

```json
{
  "v": 2,
  "t": "semantic_discover", 
  "ts": 1727100286,
  "sid": "abc123def456",
  "tool": <tool_name>,
  "does": <capability_description>,
  "when": [<trigger_contexts>],
  "good_at": [<specific_strengths>],
  "bad_at": [<known_limitations>], 
  "connector": {
    "transport": <transport_type>,
    "endpoint": <connection_url>,
    "auth": <auth_requirements>,
    "headers": <required_headers>,
    "protocol": <protocol_details>,
    "session": <session_requirements>
  },
  "proven_by": {"uses": <count>, "success_rate": <float>}
}
```

##### Field Specifications:
- `tool` (string, required): Tool identifier, max 32 chars
- `does` (string, required): Natural language capability description, max 128 chars
- `when` (array, required): Trigger contexts, max 5 items, max 64 chars each
- `good_at` (array, optional): Specific strengths, max 5 items, max 32 chars each  
- `bad_at` (array, optional): Known limitations, max 3 items, max 32 chars each
- `connector` (object, required): Connection specification (enhanced v2.6)
- `proven_by` (object, optional): Usage statistics

##### Connector Object Specification (v2.6):
```json
"connector": {
  "transport": "stdio" | "sse" | "http",
  "endpoint": "<url_or_command>",
  "auth": {
    "type": "none" | "oauth2" | "bearer" | "x402" | "api_key",
    "required": <boolean>,
    "details": <auth_specific_object>
  },
  "headers": {
    "required": [<header_name>],
    "optional": {<header_name>: <default_value>}
  },
  "protocol": {
    "type": "mcp" | "rest" | "grpc",
    "version": "<version_string>",
    "methods": [<available_methods>]
  },
  "session": {
    "required": <boolean>,
    "initialization": <init_details>
  }
}
```

**Connector Field Details:**

- `transport` (string, required): MCP connection transport type
  - `"stdio"`: Standard I/O (local command-line executable)
  - `"sse"`: HTTP Server-Sent Events (legacy MCP transport)
  - `"http"`: HTTP Streaming (modern MCP standard)
  
- `endpoint` (string, required): Connection URL or command
  - For `stdio`: Command to execute (e.g., `"npx @modelcontextprotocol/server-filesystem"`)
  - For `sse`: Full HTTP/HTTPS URL with SSE endpoint (e.g., `"https://api.example.com/sse"`)
  - For `http`: Full HTTP/HTTPS URL with MCP endpoint (e.g., `"https://api.example.com/mcp"`)
  
- `auth` (object, required): Authentication requirements (enhanced v2.6)
  - `type` (string, required): Authentication type
    - `"none"`: No authentication required (truly public)
    - `"oauth2"`: OAuth 2.0 flow required (v2.6)
    - `"bearer"`: Bearer token in Authorization header (static token)
    - `"x402"`: x402 micropayment protocol
    - `"api_key"`: API key authentication (service-level, not user-level)
  - `required` (boolean, required): Whether authentication is mandatory
  - `details` (object, conditional): Auth-specific configuration (REQUIRED if `required: true`)
  
    **For `type: "oauth2"`** (v2.6):
    ```json
    {
      "flow": "authorization_code" | "client_credentials" | "device_code",
      "auth_url": "https://provider.com/oauth/authorize",
      "token_url": "https://provider.com/oauth/token",
      "scopes": ["scope1", "scope2"],
      "instructions_url": "https://docs.provider.com/setup",
      "pkce_required": <boolean>
    }
    ```
    
    **For `type: "bearer"`**:
    ```json
    {
      "header_name": "Authorization",
      "format": "Bearer {token}",
      "instructions_url": "https://docs.provider.com/auth",
      "credential_source": "env:PROVIDER_TOKEN" | "user_input"
    }
    ```
    
    **For `type: "x402"`**:
    ```json
    {
      "network": "base-sepolia",
      "asset": "0x036CbD...",
      "currency": "USDC",
      "recipient": "0x...",
      "price_per_call": <number>
    }
    ```
    
    **For `type: "api_key"`**:
    ```json
    {
      "location": "query" | "header" | "cookie",
      "param_name": "api_key" | "X-API-Key" | custom,
      "format": "{key}" | "Bearer {key}" | "ApiKey {key}",
      "instructions_url": "https://provider.com/api-keys",
      "credential_source": "env:PROVIDER_API_KEY" | "user_input",
      "registration_url": "https://provider.com/signup"
    }
    ```
    
    **For `type: "none"`**:
    ```json
    {
      "notes": "Public endpoint, no authentication needed"
    }
    ```

- `headers` (object, optional): HTTP header requirements (v2.6)
  - `required` (array of strings, optional): Headers that MUST be present
    - Examples: `["Accept", "Content-Type"]`
  - `optional` (object, optional): Optional headers with default values
    - Examples: `{"User-Agent": "DCAP-Agent/2.6", "Accept-Encoding": "gzip"}`
  - Note: Auth headers specified in `auth.details` take precedence

- `protocol` (object, required): Protocol specification
  - `type` (string, required): Protocol type (`"mcp"`, `"rest"`, `"grpc"`)
  - `version` (string, required): Protocol version (e.g., `"2024-11-05"` for MCP)
  - `methods` (array, optional): Available methods/tools for validation

- `session` (object, optional): Session initialization requirements (v2.6)
  - `required` (boolean, required): Whether session initialization is needed
  - `initialization` (object, conditional): Init details (REQUIRED if `required: true`)
    ```json
    {
      "method": "POST" | "GET",
      "endpoint": "/init" | "/session/create",
      "payload": <init_payload_template>,
      "response_field": "session_id" | "token",
      "lifetime_seconds": <number>
    }
    ```

##### Example: OAuth2 MCP Server (v2.6)
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1730000000,
  "sid": "github-mcp",
  "tool": "create_pull_request",
  "does": "Creates pull requests in GitHub repositories",
  "when": ["create PR", "open pull request", "submit code review"],
  "good_at": ["automation", "bulk operations", "workflow integration"],
  "bad_at": ["complex merge conflicts", "interactive reviews"],
  "connector": {
    "transport": "http",
    "endpoint": "https://mcp.github.com/api",
    "auth": {
      "type": "oauth2",
      "required": true,
      "details": {
        "flow": "authorization_code",
        "auth_url": "https://github.com/login/oauth/authorize",
        "token_url": "https://github.com/login/oauth/access_token",
        "scopes": ["repo", "workflow"],
        "instructions_url": "https://docs.github.com/en/apps/creating-github-apps",
        "pkce_required": true
      }
    },
    "headers": {
      "required": ["Accept", "Content-Type"],
      "optional": {
        "Accept": "application/vnd.github.v3+json",
        "Content-Type": "application/json"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    },
    "session": {
      "required": false
    }
  },
  "proven_by": {
    "uses": 5420,
    "success_rate": 0.98
  }
}
```

##### Example: API Key Service (v2.6)
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1730000000,
  "sid": "weather-api",
  "tool": "get_forecast",
  "does": "Retrieves weather forecasts for any location worldwide",
  "when": ["get weather", "check forecast", "weather prediction"],
  "good_at": ["accurate forecasts", "global coverage", "hourly data"],
  "bad_at": ["historical data", "radar imagery"],
  "connector": {
    "transport": "http",
    "endpoint": "https://api.weatherservice.com/v1/mcp",
    "auth": {
      "type": "api_key",
      "required": true,
      "details": {
        "location": "header",
        "param_name": "X-API-Key",
        "format": "{key}",
        "instructions_url": "https://weatherservice.com/docs/authentication",
        "credential_source": "env:WEATHER_API_KEY",
        "registration_url": "https://weatherservice.com/signup"
      }
    },
    "headers": {
      "required": ["Accept"],
      "optional": {
        "Accept": "application/json"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    },
    "session": {
      "required": false
    }
  },
  "proven_by": {
    "uses": 1250,
    "success_rate": 0.99
  }
}
```

##### Example: Session-Based Service (v2.6)
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1730000000,
  "sid": "legacy-api",
  "tool": "query_database",
  "does": "Executes SQL queries against legacy database",
  "when": ["run query", "fetch data", "database search"],
  "good_at": ["complex joins", "large datasets"],
  "bad_at": ["real-time updates", "writes"],
  "connector": {
    "transport": "http",
    "endpoint": "https://legacy-db.example.com/api",
    "auth": {
      "type": "api_key",
      "required": true,
      "details": {
        "location": "header",
        "param_name": "X-API-Key",
        "format": "{key}",
        "instructions_url": "https://legacy-db.example.com/docs/api-keys",
        "credential_source": "env:LEGACY_DB_KEY"
      }
    },
    "headers": {
      "required": ["Accept", "Content-Type"],
      "optional": {
        "Accept": "application/json, text/event-stream",
        "Content-Type": "application/json"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    },
    "session": {
      "required": true,
      "initialization": {
        "method": "POST",
        "endpoint": "/session/init",
        "payload": {
          "client_id": "{{api_key}}",
          "version": "v1"
        },
        "response_field": "session_token",
        "lifetime_seconds": 3600
      }
    }
  },
  "proven_by": {
    "uses": 823,
    "success_rate": 0.94
  }
}
```

##### Example: HTTP Streaming MCP Server with x402 Payment
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1759843829,
  "sid": "robonet-mcp",
  "tool": "get_strategy_code",
  "does": "Retrieves algorithmic trading strategy source code and configuration",
  "when": ["need trading strategy", "backtest algorithm", "review strategy code"],
  "good_at": ["fast retrieval", "validated strategies", "multiple timeframes"],
  "bad_at": ["real-time execution", "strategy optimization"],
  "connector": {
    "transport": "http",
    "endpoint": "https://robonet.example.com:8080/mcp",
    "auth": {
      "type": "x402",
      "required": true,
      "details": {
        "network": "base-sepolia",
        "asset": "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
        "currency": "USDC",
        "recipient": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
        "price_per_call": 100000
      }
    },
    "headers": {
      "required": ["Accept", "Content-Type"],
      "optional": {
        "Accept": "application/json, text/event-stream",
        "Content-Type": "application/json"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call", "resources/list"]
    },
    "session": {
      "required": false
    }
  },
  "proven_by": {
    "uses": 1523,
    "success_rate": 0.97
  }
}
```

##### Example: Local stdio MCP Server (No Auth)
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1759843829,
  "sid": "filesystem-local",
  "tool": "read_file",
  "does": "Reads file contents from local filesystem with encoding detection",
  "when": ["need file contents", "read configuration", "analyze source code"],
  "good_at": ["large files", "multiple encodings", "streaming"],
  "bad_at": ["remote files", "binary files"],
  "connector": {
    "transport": "stdio",
    "endpoint": "npx @modelcontextprotocol/server-filesystem /workspace",
    "auth": {
      "type": "none",
      "required": false,
      "details": {
        "notes": "Local filesystem access, no authentication needed"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    },
    "session": {
      "required": false
    }
  },
  "proven_by": {
    "uses": 8472,
    "success_rate": 0.99
  }
}
```

##### Example: SSE MCP Server with Bearer Token (v2.6)
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1759843829,
  "sid": "smithery-mcp",
  "tool": "fetch_webpage",
  "does": "Fetches and extracts content from web pages",
  "when": ["get webpage", "scrape content", "extract data"],
  "good_at": ["javascript rendering", "clean extraction", "rate limiting"],
  "bad_at": ["captcha bypass", "authentication flows"],
  "connector": {
    "transport": "sse",
    "endpoint": "https://server.smithery.ai/@smithery-ai/fetch/mcp",
    "auth": {
      "type": "oauth2",
      "required": true,
      "details": {
        "flow": "authorization_code",
        "auth_url": "https://smithery.ai/oauth/authorize",
        "token_url": "https://smithery.ai/oauth/token",
        "scopes": ["mcp:read", "mcp:execute"],
        "instructions_url": "https://smithery.ai/docs/authentication",
        "pkce_required": false
      }
    },
    "headers": {
      "required": ["Accept"],
      "optional": {
        "Accept": "text/event-stream, application/json"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    },
    "session": {
      "required": false
    }
  },
  "proven_by": {
    "uses": 342,
    "success_rate": 0.95
  }
}
```

#### 3.2.2 Performance Update Message (`t: "perf_update"`)
Reports execution performance metrics, cost data, and optional invocation context.

**Version 2.1 Update**: Enhanced with optional execution context including sanitized arguments.

**Version 2.2 Update**: Added cost tracking for economic efficiency optimization.

```json
{
  "v": 2,
  "t": "perf_update",
  "ts": 1727100286, 
  "sid": "abc123def456",
  "tool": <tool_name>,
  "exec_ms": <execution_time>,
  "success": <boolean>,
  "cost_paid": <number>,
  "currency": <string>,
  "ctx": <context_object>
}
```

##### Field Specifications:
- `tool` (string, required): Tool identifier
- `exec_ms` (number, required): Execution time in milliseconds
- `success` (boolean, required): Whether execution succeeded
- `cost_paid` (number, optional): Actual cost charged in smallest currency units (v2.2)
- `currency` (string, optional): Currency identifier (e.g., "USDC", "ETH") (v2.2)
- `ctx` (object, optional): Execution context, MAY include:
  - `args` (object, optional): Sanitized input parameters (see 6.3.1)
  - `result_size` (number, optional): Response size in bytes
  - `cache_hit` (boolean, optional): Cache status
  - `error_code` (string, optional): Error identifier if `success: false`
  - `auth_method` (string, optional): Authentication method used (v2.6)
  - Additional implementation-specific fields

##### Example with Cost Tracking (v2.2):
```json
{
  "v": 2,
  "t": "perf_update",
  "ts": 1759843829,
  "sid": "workbench-mcp",
  "tool": "get_strategy_code",
  "exec_ms": 450,
  "success": true,
  "cost_paid": 1000000,
  "currency": "USDC",
  "ctx": {
    "args": {
      "strategy_name": "AIEnhancedPattern..."
    },
    "result_size": 15420,
    "cache_hit": false,
    "auth_method": "x402"
  }
}
```

**Note on cost_paid**: Value is in smallest currency units (e.g., 1000000 = 0.001 USDC with 6 decimals). Implementations should document their currency's decimal precision.

#### 3.2.3 Error Pattern Message (`t: "error_pattern"`)  
Describes failure modes and mitigation strategies.

```json
{
  "v": 2,
  "t": "error_pattern",
  "ts": 1727100286,
  "sid": "abc123def456", 
  "tool": <tool_name>,
  "error": <error_type>,
  "trigger": <failure_conditions>,
  "solution": <recommended_action>
}
```

## 4. Transport Protocol Requirements

### 4.1 UDP Advertisement Protocol
- **Port**: 10191
- **Packet Size**: MUST NOT exceed 1472 bytes (avoid fragmentation)
- **Encoding**: UTF-8 JSON
- **Reliability**: Best effort delivery (fire-and-forget)
- **Size Management** (v2.6 updated): If message with enhanced `connector` exceeds 1400 bytes, implementations SHOULD truncate in this priority order:
  1. Omit `connector.session` object
  2. Omit `connector.headers.optional` object
  3. Omit `connector.protocol.methods` array
  4. Truncate `auth.details.instructions_url` to domain only
  5. Omit `auth.details.registration_url`
  6. Keep: `tool`, `connector.transport`, `connector.endpoint`, `connector.auth.type`, `connector.auth.required`

### 4.2 WebSocket Distribution Protocol  
- **Upgrade Protocol**: HTTP/1.1 WebSocket upgrade
- **Subprotocol**: `dcap-v2`
- **Message Format**: JSON text frames
- **Heartbeat**: PING/PONG every 30 seconds

## 5. Discovery Algorithm

### 5.1 Agent Discovery Process
```
1. Agent receives task request
2. Parse semantic intent from request
3. Query accumulated tool knowledge base
4. Match intent against tool descriptions using:
   a. Direct keyword matching in 'when' array
   b. Semantic similarity scoring on 'does' field  
   c. Capability intersection with 'good_at' array
5. Rank candidates by:
   a. proven_by.success_rate (reliability)
   b. Average exec_ms (speed) (v2.1)
   c. Average cost_paid (economic efficiency) (v2.2)
   d. Auth complexity (prefer 'none' > 'api_key' > 'bearer' > 'oauth2') (v2.6)
6. Extract connector details from selected tool (v2.5, enhanced v2.6):
   a. Parse transport type and endpoint
   b. Check authentication requirements and available credentials
   c. Verify required headers can be provided
   d. Prepare session initialization if needed
   e. Establish connection according to protocol type
7. Execute task with acquired capability
```

### 5.2 Semantic Matching Requirements
Implementations SHOULD support:
- Exact string matching for triggers
- Fuzzy string matching (edit distance < 3)
- Semantic similarity scoring (cosine similarity > 0.7)

### 5.3 Chain Pattern Detection (v2.1)
Intelligence consumers MAY track sequences of `perf_update` messages to identify tool usage patterns:
- Group messages by `sid` (server identifier)
- Track temporal proximity (typically 5-minute window)
- Build statistical models of successful tool sequences
- Use patterns to recommend optimized workflows

### 5.4 Economic Efficiency Optimization (v2.2)
When `cost_paid` and `currency` are present, intelligence consumers SHOULD:
- Track total cost alongside execution time
- Calculate efficiency score: `success_rate / (exec_ms + normalized_cost)`
- Identify cost-effective alternatives for equivalent capabilities
- Optimize tool chains for both speed and cost

### 5.5 Dynamic Tool Acquisition (v2.5, enhanced v2.6)
Agents implementing dynamic acquisition MUST:

1. **Validate Connector**: Verify transport type is supported and all required fields are present

2. **Check Authentication Availability** (v2.6):
   - For `oauth2`: Determine if OAuth flow can be completed (interactive vs. automated)
   - For `bearer`: Check if token is available in secure storage or environment
   - For `api_key`: Verify API key is available or prompt user with `registration_url`
   - For `x402`: Confirm wallet connection and sufficient balance
   - For `none`: Proceed without authentication
   - If credentials unavailable, SHOULD skip tool or prompt user with `instructions_url`

3. **Prepare HTTP Headers** (v2.6):
   - Include all headers from `connector.headers.required`
   - Apply defaults from `connector.headers.optional` if not overridden
   - Add authentication headers per `auth.details` specification

4. **Initialize Session** (v2.6):
   - If `session.required: true`, perform initialization handshake
   - Store session token/ID for subsequent requests
   - Track session lifetime and refresh as needed

5. **Establish Connection**: Based on transport type:
   - `stdio`: Spawn child process with specified command
   - `sse`: Open HTTP connection, establish SSE stream with proper headers
   - `http`: Open HTTP connection, use streaming HTTP with proper headers

6. **Verify Protocol**: Confirm protocol type and version compatibility

7. **Invoke Tool**: Execute tool call according to protocol specification

8. **Handle Errors**: Implement retry logic and fallback to alternative tools
   - Auth errors (401/403): Re-acquire credentials or skip tool
   - Session expired: Re-initialize session
   - Rate limits (429): Exponential backoff
   - Server errors (5xx): Try alternative tool

### 5.6 Credential Management (v2.6)
Agents SHOULD implement a credential manager that:
- Stores OAuth tokens securely with refresh capability
- Maps `credential_source` identifiers to actual credentials
- Prompts users for missing credentials using `instructions_url` or `registration_url`
- Respects credential scoping (tool-specific vs. service-wide)
- Implements secure storage (OS keychain, encrypted vault, etc.)

## 6. Security Considerations

### 6.1 Denial of Service Protection
- Rate limiting: Max 100 messages per source IP per minute
- Message size validation: Reject packets > 1472 bytes
- Malformed message filtering: Strict JSON schema validation

### 6.2 Capability Validation
- Agents MUST validate tool endpoints before connection
- Sandbox unknown tools during initial execution
- Monitor tool behavior for anomalies
- Verify TLS certificates for `https://` endpoints (v2.5)
- For `stdio` transport, validate commands are from trusted sources
- Validate OAuth redirect URIs match `auth_url` domain (v2.6)
- Never execute stdio commands with user-controlled input

### 6.3 Privacy Considerations
- Server identifiers SHOULD be pseudonymous
- No personally identifiable information in broadcasts
- Tool usage patterns may reveal sensitive information
- Cost data is semi-public by nature (on-chain transactions)

#### 6.3.1 Argument Sanitization (v2.1)
When including `ctx.args` in `perf_update` messages, implementations MUST:
- **Truncate** string values exceeding 32 characters (append "...")
- **Hash** or **omit** values containing:
  - API keys, tokens, or credentials
  - Personally identifiable information (PII)
  - Sensitive business data
  - File paths revealing system structure
- **Consider** omitting `ctx.args` entirely if sanitization is complex

##### Example Sanitization:
```javascript
// Original args
{
  "api_key": "sk_live_abc123...",
  "user_email": "user@example.com",
  "query": "What are the top performing strategies?"
}

// Sanitized for broadcast
{
  "api_key": "[REDACTED]",
  "user_email": "[REDACTED]", 
  "query": "What are the top performin..."
}
```

#### 6.3.2 Cost Data Transparency (v2.2)
Cost information in `perf_update` messages:
- Reflects actual charged amount, not internal pricing structure
- Is already observable through blockchain/payment protocol
- Enables market efficiency through price transparency
- Tools MAY omit cost data if business model requires confidentiality

#### 6.3.3 Endpoint Security (v2.5, updated v2.6)
When broadcasting `connector` information:
- **Public Endpoints**: Include full connection details with comprehensive auth instructions
- **Private Endpoints**: Use access-controlled relay or omit from public broadcasts
- **Authentication**: NEVER include actual credentials (keys, tokens, passwords) in broadcasts
  - Only specify the `auth.type` and where to obtain credentials
  - Use `instructions_url` and `registration_url` to guide credential acquisition
  - For OAuth2, include redirect URLs but not client secrets
- **TLS Required**: All public HTTP endpoints MUST use `https://` URLs
- **Command Injection**: For `stdio` transport, validate command strings are from trusted package managers (npm, pip, etc.)

#### 6.3.4 OAuth Security (v2.6)
For OAuth2 authentication:
- Implementations MUST validate `redirect_uri` matches expected domain
- Client secrets MUST NOT be included in broadcasts
- Use PKCE for public clients when `pkce_required: true`
- Tokens MUST be stored securely and never logged or broadcast
- Refresh tokens SHOULD be rotated according to provider policy

## 7. Implementation Guidelines  

### 7.1 Tool Provider Requirements
Tools implementing DCAP MUST:
- Generate unique, stable server identifiers
- Broadcast `semantic_discover` on first capability use with complete `connector` details (v2.5)
- Include comprehensive auth details per v2.6 specification
- Specify all required HTTP headers in `connector.headers`
- Document session initialization requirements if applicable
- Send `perf_update` messages for significant events
- Respect UDP packet size limits (prioritize critical fields)
- Sanitize arguments before including in `ctx.args` (v2.1)
- Report actual cost charged in `cost_paid` when applicable (v2.2)
- Ensure `connector.endpoint` is reachable from agent networks
- Keep authentication requirements current in `connector.auth`
- Provide valid `instructions_url` for credential acquisition (v2.6)

### 7.2 Agent Consumer Requirements  
Agents implementing DCAP MUST:
- Maintain local capability knowledge base
- Handle UDP packet loss gracefully
- Implement connection retry logic for tool acquisition
- Validate tool responses before use
- Respect privacy of observed `ctx.args` data (v2.1)
- Consider cost alongside performance when selecting tools (v2.2)
- Parse and validate `connector` information before attempting connection (v2.5)
- Implement secure credential storage for auth tokens (v2.5)
- Support multiple transport types or gracefully skip unsupported tools (v2.5)
- Handle OAuth flows or prompt users with `instructions_url` (v2.6)
- Respect `headers.required` when making HTTP requests (v2.6)
- Implement session initialization per `session` specification (v2.6)
- Check credential availability before attempting tool calls (v2.6)

### 7.3 Hub Implementation Requirements
Intelligence hubs MUST:
- Accept UDP packets on port 10191  
- Relay messages via WebSocket without modification
- Support multiple concurrent WebSocket connections
- Implement basic DoS protection

### 7.4 Intelligence Consumer Requirements (v2.1, updated v2.2, v2.5, v2.6)
Systems consuming DCAP streams for intelligence (e.g., Oracle agents) SHOULD:
- Track `perf_update` sequences by `sid` for pattern detection
- Maintain statistical models of tool performance AND cost (v2.2)
- Respect privacy constraints when analyzing `ctx.args`
- Only recommend patterns that were ACTUALLY OBSERVED
- Calculate efficiency metrics incorporating both time and cost (v2.2)
- Index tools by `connector.transport` for transport-specific recommendations (v2.5)
- Track authentication requirements to inform agents of payment/access needs (v2.5)
- Classify tools by `auth.type` complexity for smart recommendations (v2.6)
- Monitor authentication success rates per auth method (v2.6)
- Identify tools that commonly fail authentication to warn agents

## 8. References

### 8.1 Normative References
- [RFC2119] Key words for use in RFCs
- [RFC6455] The WebSocket Protocol  
- [RFC768] User Datagram Protocol
- [RFC6749] OAuth 2.0 Authorization Framework
- [RFC7636] Proof Key for Code Exchange (PKCE)
- [MCP] Model Context Protocol Specification

### 8.2 Informative References
- [AutoGPT] Autonomous GPT-4 Experiment
- [LangChain] Framework for developing applications with LLMs
- [x402] x402 Micropayment Protocol

## 9. Changelog

### Version 2.6 (November 2025)
**Added:**
- OAuth2 as distinct authentication type with flow specification
- `auth.details` comprehensive specifications for each auth type
- `instructions_url` for credential acquisition guidance
- `registration_url` for new user signups
- `credential_source` to specify where credentials should be loaded from
- `headers` object with `required` and `optional` specifications
- `session` object for session initialization requirements
- `pkce_required` flag for OAuth2 PKCE flows
- Section 5.6: Credential management guidelines
- Section 6.3.4: OAuth security considerations
- Enhanced auth error handling in Section 5.5
- Updated ranking to consider auth complexity
- Appendix B: Auth type decision tree
- Appendix C: Common auth patterns

**Changed:**
- `bearer` type now specifically for static bearer tokens (not OAuth2)
- API key specification now includes `format` and `location` details
- UDP size management updated for new fields
- `perf_update` now tracks `auth_method` in context

**Rationale:**
- Testing revealed auth information insufficient for autonomous connection
- Many tools failed due to missing OAuth flows, required headers, session init
- Agents need explicit guidance on credential acquisition
- Separation of OAuth2 from bearer tokens eliminates ambiguity
- Header requirements prevent content negotiation failures
- Session initialization details enable stateful service connections
- Enables truly autonomous tool acquisition without manual configuration debugging

**Migration from v2.5:**
- Tools using `"bearer"` for OAuth should change to `"oauth2"` with flow details
- Add `headers` object if specific headers required (common for SSE endpoints)
- Add `session` object if session initialization needed
- Enhance `auth.details` with `instructions_url` and credential source
- Backward compatible: v2.5 consumers ignore new fields, still function with degraded UX

### Version 2.5 (October 2025)
**Added:**
- `connector` object to `semantic_discover` message with structured connection details
- `transport` field specifying connection type (websocket, stdio, http, https)
- `endpoint` field with full connection URL or command
- `auth` object with authentication type and requirements
- `protocol` object specifying protocol type, version, and methods
- Section 5.5: Dynamic tool acquisition guidelines
- Section 6.2: TLS certificate validation requirement
- Section 6.3.3: Endpoint security considerations
- Updated implementation requirements for v2.5 features

**Removed:**
- Deprecated `connects_to` field (replaced by structured `connector` object)

**Rationale:**
- Enables fully autonomous tool acquisition without manual configuration
- Agents can programmatically connect to any discovered tool
- Structured authentication details enable automated credential management
- Transport specification allows agents to support multiple connection types
- Critical step toward true dynamic capability acquisition

**Migration from v2.2:**
- `connects_to` field replaced by `connector.endpoint`
- Backward compatibility: Consumers can fall back to treating `connects_to` as simple endpoint
- New implementations MUST use `connector` object
- Existing v2.2 implementations continue to work but miss dynamic acquisition benefits

### Version 2.2 (October 2025)
**Added:**
- `cost_paid` field to `perf_update` message for economic tracking
- `currency` field to `perf_update` message for multi-currency support
- Section 5.4: Economic efficiency optimization guidelines
- Section 6.3.2: Cost data transparency considerations
- Updated Section 5.1: Ranking now includes cost optimization

**Rationale:**
- Performance includes both speed and cost
- Oracle agents need cost data to recommend economically efficient tool chains
- Transparency enables market efficiency and price discovery
- Cost is already semi-public through payment protocols (e.g., x402, blockchain)
- Maintains backward compatibility (cost fields optional)

### Version 2.1 (October 2025)
**Added:**
- Enhanced `perf_update` message with optional `ctx` object
- Support for sanitized `ctx.args` in performance updates
- Section 5.3: Chain pattern detection guidelines
- Section 6.3.1: Argument sanitization requirements
- Section 7.4: Intelligence consumer requirements

**Rationale:**
- Enables pattern detection and chain optimization without introducing new message types
- Maintains backward compatibility (all new fields optional)
- Addresses privacy concerns through explicit sanitization requirements

### Version 2.0 (September 2025)
- Initial public specification

## Appendix A. Example Dynamic Acquisition Implementation

```javascript
// Dynamic Tool Acquisition Client (v2.6)
class DynamicDCAPAgent {
  constructor() {
    this.knownTools = new Map();
    this.credentialManager = new CredentialManager();
    this.ws = new WebSocket('ws://hub:10191', 'dcap-v2');
    this.ws.onmessage = this.handleMessage.bind(this);
  }
  
  handleMessage(event) {
    const msg = JSON.parse(event.data);
    if (msg.t === 'semantic_discover') {
      this.knownTools.set(msg.tool, msg);
    }
  }
  
  async acquireAndInvokeTool(capability, args) {
    // 1. Find matching tool
    const tool = this.findBestTool(capability);
    if (!tool) throw new Error('No tool found for capability');
    
    // 2. Extract connector details
    const { transport, endpoint, auth, headers, protocol, session } = tool.connector;
    
    // 3. Check authentication availability
    if (auth.required) {
      const hasCredentials = await this.credentialManager.checkAvailability(auth);
      if (!hasCredentials) {
        throw new Error(
          `Missing credentials for ${auth.type}. ` +
          `Get setup instructions at: ${auth.details.instructions_url}`
        );
      }
    }
    
    // 4. Prepare authentication
    const credentials = await this.prepareAuth(auth);
    
    // 5. Prepare headers
    const requestHeaders = this.prepareHeaders(headers, credentials, auth);
    
    // 6. Establish connection based on transport
    let client;
    switch (transport) {
      case 'stdio':
        client = await this.spawnStdio(endpoint, protocol);
        break;
      case 'sse':
        client = await this.connectSSE(endpoint, requestHeaders, protocol);
        break;
      case 'http':
        client = await this.connectHTTPStreaming(endpoint, requestHeaders, protocol);
        break;
      default:
        throw new Error(`Unsupported transport: ${transport}`);
    }
    
    // 7. Initialize session if required
    if (session?.required) {
      await this.initializeSession(client, endpoint, session, requestHeaders);
    }
    
    // 8. Invoke tool
    const result = await client.callTool(tool.tool, args);
    
    // 9. Clean up
    await client.disconnect();
    
    return result;
  }
  
  async prepareAuth(authConfig) {
    if (!authConfig.required) return null;
    
    switch (authConfig.type) {
      case 'none':
        return null;
        
      case 'oauth2':
        // Handle OAuth2 flow
        const token = await this.credentialManager.getOAuth2Token(
          authConfig.details.auth_url,
          authConfig.details.token_url,
          authConfig.details.scopes,
          authConfig.details.pkce_required
        );
        return { oauth_token: token };
        
      case 'bearer':
        // Retrieve static bearer token
        const bearerToken = await this.credentialManager.getCredential(
          authConfig.details.credential_source
        );
        return { bearer_token: bearerToken };
        
      case 'x402':
        // Initialize payment stream
        const { network, asset, price_per_call } = authConfig.details;
        return await this.initializeX402Payment(network, asset, price_per_call);
        
      case 'api_key':
        const apiKey = await this.credentialManager.getCredential(
          authConfig.details.credential_source
        );
        return { api_key: apiKey };
        
      default:
        throw new Error(`Unsupported auth type: ${authConfig.type}`);
    }
  }
  
  prepareHeaders(headersConfig, credentials, authConfig) {
    const headers = {};
    
    // Add optional defaults first
    if (headersConfig?.optional) {
      Object.assign(headers, headersConfig.optional);
    }
    
    // Add authentication headers
    if (credentials) {
      if (credentials.oauth_token) {
        headers['Authorization'] = `Bearer ${credentials.oauth_token}`;
      } else if (credentials.bearer_token) {
        const format = authConfig.details.format || 'Bearer {token}';
        headers['Authorization'] = format.replace('{token}', credentials.bearer_token);
      } else if (credentials.api_key && authConfig.details.location === 'header') {
        const format = authConfig.details.format || '{key}';
        headers[authConfig.details.param_name] = format.replace('{key}', credentials.api_key);
      } else if (credentials.x402) {
        headers['X-Payment'] = credentials.x402.paymentHeader;
      }
    }
    
    // Ensure required headers are present
    if (headersConfig?.required) {
      for (const reqHeader of headersConfig.required) {
        if (!headers[reqHeader]) {
          throw new Error(`Required header missing: ${reqHeader}`);
        }
      }
    }
    
    return headers;
  }
  
  async initializeSession(client, baseEndpoint, sessionConfig, headers) {
    const { method, endpoint: initPath, payload, response_field } = sessionConfig.initialization;
    
    const initUrl = baseEndpoint.replace(/\/[^\/]*$/, initPath);
    
    const response = await fetch(initUrl, {
      method,
      headers,
      body: method !== 'GET' ? JSON.stringify(payload) : undefined
    });
    
    const data = await response.json();
    const sessionToken = data[response_field];
    
    // Store session token for subsequent requests
    client.setSessionToken(sessionToken);
    
    return sessionToken;
  }
  
  async connectSSE(endpoint, headers, protocol) {
    // SSE (Server-Sent Events) - Legacy MCP transport
    // Note: SSE requires specific Accept header
    const sseHeaders = {
      ...headers,
      'Accept': 'text/event-stream, application/json'
    };
    
    const EventSource = require('eventsource');
    const es = new EventSource(endpoint, { headers: sseHeaders });
    
    let sessionToken = null;
    
    return {
      callTool: async (toolName, args) => {
        const requestHeaders = { ...sseHeaders };
        if (sessionToken) {
          requestHeaders['X-Session-Token'] = sessionToken;
        }
        
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: requestHeaders,
          body: JSON.stringify({
            jsonrpc: '2.0',
            method: 'tools/call',
            params: { name: toolName, arguments: args },
            id: Date.now()
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${await response.text()}`);
        }
        
        return await response.json();
      },
      setSessionToken: (token) => {
        sessionToken = token;
      },
      disconnect: async () => {
        es.close();
      }
    };
  }
  
  async connectHTTPStreaming(endpoint, headers, protocol) {
    // HTTP Streaming - Modern MCP transport
    let sessionToken = null;
    
    // Perform MCP initialization
    await this.sendMCPInitializeHTTP(endpoint, headers, protocol.version);
    
    return {
      callTool: async (toolName, args) => {
        const requestHeaders = { ...headers };
        if (sessionToken) {
          requestHeaders['X-Session-Token'] = sessionToken;
        }
        
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: requestHeaders,
          body: JSON.stringify({
            jsonrpc: '2.0',
            method: 'tools/call',
            params: { name: toolName, arguments: args },
            id: Date.now()
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${await response.text()}`);
        }
        
        const result = await response.json();
        return result.error ? Promise.reject(result.error) : result.result;
      },
      setSessionToken: (token) => {
        sessionToken = token;
      },
      disconnect: async () => {
        // HTTP is stateless, no cleanup needed
      }
    };
  }
  
  async spawnStdio(command, protocol) {
    const { spawn } = require('child_process');
    const proc = spawn(command, { shell: true, stdio: ['pipe', 'pipe', 'inherit'] });
    
    // Perform MCP initialization
    await this.sendMCPInitialize(proc.stdin, protocol.version);
    
    return {
      callTool: async (toolName, args) => {
        const request = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: { name: toolName, arguments: args },
          id: Date.now()
        };
        
        proc.stdin.write(JSON.stringify(request) + '\n');
        
        // Read response
        return new Promise((resolve, reject) => {
          const handler = (data) => {
            const response = JSON.parse(data.toString());
            if (response.id === request.id) {
              proc.stdout.removeListener('data', handler);
              response.error ? reject(response.error) : resolve(response.result);
            }
          };
          proc.stdout.on('data', handler);
        });
      },
      setSessionToken: () => {
        // stdio doesn't use session tokens
      },
      disconnect: async () => {
        proc.kill();
      }
    };
  }
  
  async sendMCPInitialize(stream, version) {
    // For stdio transport
    const init = {
      jsonrpc: '2.0',
      method: 'initialize',
      params: {
        protocolVersion: version,
        clientInfo: { name: 'dynamic-dcap-agent', version: '2.6.0' }
      },
      id: 1
    };
    
    stream.write(JSON.stringify(init) + '\n');
    
    // Wait for initialize response (simplified)
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  async sendMCPInitializeHTTP(endpoint, headers, version) {
    // For HTTP transport
    const init = {
      jsonrpc: '2.0',
      method: 'initialize',
      params: {
        protocolVersion: version,
        clientInfo: { name: 'dynamic-dcap-agent', version: '2.6.0' }
      },
      id: 1
    };
    
    await fetch(endpoint, {
      method: 'POST',
      headers,
      body: JSON.stringify(init)
    });
    
    // Wait for initialization to complete (simplified)
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  async initializeX402Payment(network, asset, pricePerCall) {
    // Use x402 library to create payment stream
    const { createPayment } = require('x402');
    
    const payment = await createPayment({
      network,
      asset,
      amount: pricePerCall * 10, // Pre-pay for 10 calls
      recipient: '0x...' // From auth.details.recipient
    });
    
    return {
      x402: {
        paymentHeader: JSON.stringify(payment)
      }
    };
  }
  
  findBestTool(capability) {
    // Semantic matching with auth complexity preference
    const candidates = [];
    
    for (const tool of this.knownTools.values()) {
      if (tool.when.some(trigger => 
        capability.toLowerCase().includes(trigger.toLowerCase())
      )) {
        // Calculate score favoring simpler auth
        const authComplexity = {
          'none': 0,
          'api_key': 1,
          'bearer': 2,
          'oauth2': 3,
          'x402': 2
        }[tool.connector.auth.type] || 5;
        
        const score = (tool.proven_by?.success_rate || 0.5) - (authComplexity * 0.05);
        candidates.push({ tool, score });
      }
    }
    
    candidates.sort((a, b) => b.score - a.score);
    return candidates[0]?.tool || null;
  }
}

// Simple Credential Manager
class CredentialManager {
  constructor() {
    this.credentials = new Map();
  }
  
  async checkAvailability(authConfig) {
    if (!authConfig.required) return true;
    
    switch (authConfig.type) {
      case 'none':
        return true;
      case 'oauth2':
        // Check if we have a valid OAuth token
        return await this.hasValidOAuthToken(authConfig.details);
      case 'bearer':
      case 'api_key':
        const source = authConfig.details.credential_source;
        return await this.hasCredential(source);
      case 'x402':
        return await this.hasX402Wallet();
      default:
        return false;
    }
  }
  
  async getCredential(source) {
    // Parse credential source (e.g., "env:API_KEY")
    if (source.startsWith('env:')) {
      const envVar = source.substring(4);
      return process.env[envVar];
    }
    if (source === 'user_input') {
      return await this.promptUser('Enter credential:');
    }
    return this.credentials.get(source);
  }
  
  async getOAuth2Token(authUrl, tokenUrl, scopes, pkceRequired) {
    // Simplified OAuth2 flow - real implementation would be more complex
    // For authorization_code flow, would need to:
    // 1. Generate PKCE challenge if required
    // 2. Open browser to authUrl
    // 3. Capture redirect with code
    // 4. Exchange code for token at tokenUrl
    // 5. Store and return access token
    
    // For now, check if we have a cached token
    const cacheKey = `oauth:${tokenUrl}:${scopes.join(',')}`;
    return this.credentials.get(cacheKey);
  }
  
  async hasValidOAuthToken(authDetails) {
    const cacheKey = `oauth:${authDetails.token_url}:${authDetails.scopes.join(',')}`;
    const token = this.credentials.get(cacheKey);
    // Should also check expiration, but simplified here
    return !!token;
  }
  
  async hasCredential(source) {
    if (source.startsWith('env:')) {
      const envVar = source.substring(4);
      return !!process.env[envVar];
    }
    return this.credentials.has(source);
  }
  
  async hasX402Wallet() {
    // Check if wallet is connected and has balance
    return false; // Simplified
  }
  
  async promptUser(message) {
    // In real implementation, would prompt user through UI
    console.log(message);
    return null;
  }
}

// Usage Example
const agent = new DynamicDCAPAgent();

// Wait for discovery
await new Promise(resolve => setTimeout(resolve, 5000));

// Dynamically acquire and invoke tool
try {
  const forecast = await agent.acquireAndInvokeTool(
    'get weather forecast',
    { location: 'San Francisco, CA' }
  );
  console.log('Weather forecast:', forecast);
} catch (error) {
  if (error.message.includes('Missing credentials')) {
    console.error('Setup required:', error.message);
  } else {
    throw error;
  }
}
```

## Appendix B. Auth Type Decision Tree (v2.6)

Tool providers should choose the appropriate auth type:

```
Is authentication needed?
├─ NO → auth.type = "none"
│
└─ YES → Does it use OAuth2?
   ├─ YES → auth.type = "oauth2"
   │        (specify flow, auth_url, token_url, scopes)
   │
   └─ NO → Is it a static token?
      ├─ YES → auth.type = "bearer"
      │        (specify format, credential_source)
      │
      └─ NO → Is it a usage-based payment?
         ├─ YES → auth.type = "x402"
         │        (specify network, asset, recipient)
         │
         └─ NO → auth.type = "api_key"
                  (specify location, param_name, format)
```

**Key Distinctions:**
- **oauth2**: Interactive user consent flow (authorization_code) or service-to-service (client_credentials)
- **bearer**: Static token that doesn't expire or uses service-managed refresh
- **api_key**: Service-level API key (not user OAuth token)
- **x402**: Pay-per-call with cryptocurrency
- **none**: Truly public, no setup required

## Appendix C. Common Auth Patterns (v2.6)

### C.1 Smithery.ai Hosted Tools
```json
{
  "auth": {
    "type": "oauth2",
    "required": true,
    "details": {
      "flow": "authorization_code",
      "auth_url": "https://smithery.ai/oauth/authorize",
      "token_url": "https://smithery.ai/oauth/token",
      "scopes": ["mcp:read", "mcp:execute"],
      "instructions_url": "https://smithery.ai/docs/authentication",
      "pkce_required": false
    }
  },
  "headers": {
    "required": ["Accept"],
    "optional": {
      "Accept": "text/event-stream, application/json"
    }
  }
}
```

### C.2 NPX/UVX stdio Tools (Public)
```json
{
  "transport": "stdio",
  "endpoint": "npx some-mcp-server",
  "auth": {
    "type": "none",
    "required": false,
    "details": {
      "notes": "Local execution, no authentication"
    }
  }
}
```

### C.3 NPX/UVX stdio Tools (API Key Required)
```json
{
  "transport": "stdio",
  "endpoint": "npx some-api-mcp-server",
  "auth": {
    "type": "api_key",
    "required": true,
    "details": {
      "location": "env",
      "param_name": "SERVICE_API_KEY",
      "format": "{key}",
      "instructions_url": "https://service.com/docs/api-keys",
      "credential_source": "env:SERVICE_API_KEY",
      "registration_url": "https://service.com/signup"
    }
  }
}
```

Note: For stdio tools, the API key is typically passed via environment variable to the spawned process.

### C.4 REST API with Header-based API Key
```json
{
  "auth": {
    "type": "api_key",
    "required": true,
    "details": {
      "location": "header",
      "param_name": "X-API-Key",
      "format": "{key}",
      "instructions_url": "https://api.provider.com/docs/authentication",
      "credential_source": "env:PROVIDER_API_KEY",
      "registration_url": "https://api.provider.com/signup"
    }
  },
  "headers": {
    "required": ["X-API-Key", "Content-Type"],
    "optional": {
      "Content-Type": "application/json"
    }
  }
}
```

### C.5 REST API with Query Parameter API Key
```json
{
  "auth": {
    "type": "api_key",
    "required": true,
    "details": {
      "location": "query",
      "param_name": "key",
      "format": "{key}",
      "instructions_url": "https://api.provider.com/docs/auth",
      "credential_source": "env:PROVIDER_KEY",
      "registration_url": "https://api.provider.com/register"
    }
  }
}
```

Note: When `location: "query"`, the agent must append `?key={value}` or `&key={value}` to the endpoint URL.

## Authors' Addresses

Martin Maurer  
Email: empeamtk@googlemail.com

