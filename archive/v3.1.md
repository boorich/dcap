# Dynamic Capability Acquisition Protocol (DCAP)

**Version**: 3.1  
**Date**: December 2025  
**Author**: M. Maurer  

## Abstract

This document defines the Dynamic Capability Acquisition Protocol (DCAP), a decentralized protocol enabling autonomous agents to discover, evaluate, and acquire computational capabilities at runtime through semantic broadcasting. DCAP uses UDP multicast for capability advertisement and WebSocket streams for real-time intelligence distribution.

Version 3.1 introduces **categorical compliance** based on the formal C_cap category theory foundation. Capabilities form a mathematical category where tools are morphisms with typed signatures, enabling verified composition with provable correctness guarantees.

## 1. Introduction

### 1.1 Problem Statement
Current autonomous agent systems operate with fixed, pre-configured tool sets, limiting their ability to handle novel or specialized tasks. Existing tool discovery mechanisms rely on centralized registries, creating bottlenecks and single points of failure. Additionally, discovered tools often lack sufficient connection metadata, making autonomous acquisition impractical. Tool-provided performance metrics (self-reports) may not reflect actual observed behavior, limiting trustworthy reputation systems. Finally, ad-hoc tool chaining lacks formal guarantees — agents cannot verify that compositions are well-typed or that costs are predictable.

### 1.2 Solution Overview
DCAP enables tools to self-advertise their capabilities using semantic descriptions and typed signatures, allowing agents to discover and dynamically load appropriate tools based on task requirements rather than static configuration. Version 3.1 introduces:

- **Typed signatures**: Tools declare explicit input/output types enabling verified composition
- **Categorical compliance**: The C_cap category structure guarantees identity and associativity laws
- **Composite capabilities**: Agents can declare and execute verified tool chains
- **Cost enrichment**: Costs are additive under composition, enabling predictable pricing

These additions build on v3.0's distinction between tool self-reports (`perf_update`) and agent observations (`usage_receipt`), enabling intelligence systems to build reputation from third-party data.

### 1.3 Categorical Foundation

DCAP v3.1 capabilities form a category **C_cap** where:

- **Objects**: Capability types (Text, Image, JSON, etc.)
- **Morphisms**: Tools with typed signatures A → B
- **Composition**: Tool chaining (g ∘ f)
- **Identity**: No-op transforms id_A for each type A
- **Enrichment**: Costs over the monoid (ℕ, +, 0)

#### 1.3.1 Category Laws

All C_cap-compliant tools and compositions MUST satisfy:

```
Left Identity:   id_B ∘ f = f       (for f : A → B)
Right Identity:  f ∘ id_A = f       (for f : A → B)
Associativity:   h ∘ (g ∘ f) = (h ∘ g) ∘ f
```

#### 1.3.2 Cost Enrichment Law

Costs MUST be additive under composition:

```
cost(id_A) = 0                      (identity has zero cost)
cost(g ∘ f) = cost(f) + cost(g)     (costs sum under composition)
```

Agents MUST reject compositions where declared cost ≠ sum of component costs.

#### 1.3.3 Compliance Levels

DCAP v3.1 defines two compliance levels:

- **C_cap-compliant**: Tool has valid `signature` with registered types; can participate in verified composition
- **DCAP-basic**: No `signature`; uses `does`/`when` for discovery only; cannot participate in typed composition

Both levels are valid DCAP participants. Agents operating in typed mode SHOULD prefer C_cap-compliant tools for composition but MAY fall back to DCAP-basic tools for standalone invocation.

## 2. Protocol Architecture

### 2.1 Network Topology
```
Tool Provider → UDP Broadcast → Intelligence Hub → WebSocket → Agent Consumer
     ^                              ^                   ^           ^
   MCP Tool                   Stream Aggregator    Real-time     Dynamic Agent
   (has sid)                                                    (has agent_id)
     ↓                                                                ↓
perf_update (self-report)                                   usage_receipt (observation)
                                                            composite_receipt (chain observation)
```

### 2.2 Transport Layers
- **Advertisement Layer**: UDP packets (port 10191)
- **Distribution Layer**: WebSocket streams 
- **Acquisition Layer**: MCP protocol over stdio/HTTP/SSE (specified in connector)

### 2.3 Message Sources
DCAP distinguishes between two types of broadcasters:

- **Tools** (MCP servers): Identified by `sid`, broadcast capabilities and self-reports
- **Agents** (consumers): Identified by `agent_id`, broadcast observed tool behavior and compositions

This distinction enables intelligence systems to compare tool claims against agent observations.

## 3. Type Registry

C_cap-compliant tools declare input/output types from a canonical registry.

### 3.1 Core Types

The following types are defined by the protocol:

| Type | Description |
|------|-------------|
| `Text` | UTF-8 encoded text |
| `JSON` | Valid JSON document |
| `Image` | Binary image data (PNG, JPEG, WebP, etc.) |
| `Audio` | Binary audio data |
| `Video` | Binary video data |
| `Binary` | Arbitrary binary data |
| `URL` | Valid URL string |
| `HTML` | HTML document |
| `Markdown` | Markdown formatted text |
| `PDF` | PDF document |
| `Bool` | Boolean value |
| `Number` | Numeric value |
| `List<T>` | Ordered list of type T |
| `Maybe<T>` | Optional value of type T (for fallible tools) |
| `Void` | Unit type (for effects-only tools) |

### 3.2 Extended Types

Tools MAY define custom types using namespaced identifiers:

```
org.example:Invoice
com.company:CustomerRecord
dcap.finance:SECFiling
```

Custom types SHOULD be documented by their defining organization. Agents encountering unknown types MAY treat them as opaque `Binary` for transport purposes but MUST NOT assume composability.

### 3.3 Effect Types

Tools with effects MUST declare them in their signature:

| Effect Type | Meaning |
|-------------|---------|
| `Maybe<T>` | May fail, returns T on success |
| `List<T>` | Non-deterministic, returns multiple results |
| `IO<T>` | Performs external effects, returns T |

A tool declared as `Text → Text` MUST always succeed. A tool that may fail MUST declare `Text → Maybe<Text>`.

**Note:** Kleisli composition for effect types is planned for v3.2. In v3.1, compositions involving effect types require agents to handle unwrapping between steps.

## 4. Message Format Specification

### 4.1 Base Message Structure
All DCAP messages MUST conform to this JSON schema:

```json
{
  "v": <protocol_version>,
  "t": <message_type>, 
  "ts": <unix_timestamp>,
  "sid": <server_identifier>,     // for tool messages
  "agent_id": <agent_identifier>, // for agent messages
  [message_specific_fields]
}
```

#### Required Fields:
- `v` (number): Protocol version (current: 2)
- `t` (string): Message type identifier
- `ts` (number): Unix timestamp of message creation
- `sid` (string): Unique server identifier (8-12 characters) - for tool messages
- `agent_id` (string): Unique agent identifier (8-32 characters) - for agent messages

### 4.2 Message Types Overview

| Message Type | Broadcaster | Purpose |
|--------------|-------------|---------|
| `semantic_discover` | Tools | Advertise capabilities with typed signatures |
| `perf_update` | Tools | Self-report execution metrics |
| `usage_receipt` | Agents | Report observed tool behavior |
| `composite_capability` | Agents | Declare verified tool composition |
| `composite_receipt` | Agents | Report composition execution |
| `error_pattern` | Tools | Report recurring error patterns |

### 4.3 Semantic Discovery Message (`t: "semantic_discover"`)
Advertises tool capabilities using natural language descriptions, typed signatures, and comprehensive connection information.

**Broadcast by:** Tools (MCP servers)

```json
{
  "v": 3,
  "t": "semantic_discover", 
  "ts": 1727100286,
  "sid": "abc123def456",
  "tool": <tool_name>,
  "signature": {
    "input": <input_type>,
    "output": <output_type>,
    "cost": <cost_value>
  },
  "identity": <boolean>,
  "does": <capability_description>,
  "when": [<trigger_contexts>],
  "good_at": [<specific_strengths>],
  "bad_at": [<known_limitations>], 
  "connector": {
    "transport": <transport_type>,
    "endpoint": <connection_url>,
    "auth": <auth_requirements>,
    "headers": <required_headers>,
    "protocol": <protocol_details>,
    "session": <session_requirements>
  },
  "proven_by": {"uses": <count>, "success_rate": <float>}
}
```

#### 4.3.1 Signature Fields (NEW in v3.1):

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `signature` | object | For C_cap | Typed morphism declaration |
| `signature.input` | string | Yes | Input type from registry |
| `signature.output` | string | Yes | Output type from registry |
| `signature.cost` | integer | Yes | Declared cost (≥ 0) |
| `identity` | boolean | No | True if this is an identity morphism |

#### 4.3.2 Semantic Fields:

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `tool` | string | Yes | Tool identifier, max 32 chars |
| `does` | string | Yes | Natural language capability description, max 128 chars |
| `when` | array | Yes | Trigger contexts, max 5 items, max 64 chars each |
| `good_at` | array | No | Specific strengths, max 5 items, max 32 chars each |
| `bad_at` | array | No | Known limitations, max 3 items, max 32 chars each |
| `proven_by` | object | No | Usage statistics (calculation method not prescribed) |

#### 4.3.3 Connector Object Specification:

```json
"connector": {
  "transport": "stdio" | "sse" | "http",
  "endpoint": "<url_or_command>",
  "auth": {
    "type": "none" | "oauth2" | "bearer" | "x402" | "api_key",
    "required": <boolean>,
    "details": <auth_specific_object>
  },
  "headers": {
    "required": [<header_name>],
    "optional": {<header_name>: <default_value>}
  },
  "protocol": {
    "type": "mcp" | "rest" | "grpc",
    "version": "<version_string>",
    "methods": [<available_methods>]
  },
  "session": {
    "required": <boolean>,
    "initialization": <init_details>
  }
}
```

**Connector Field Details:**

- `transport` (string, required): Connection transport type
  - `"stdio"`: Standard input/output (local process)
  - `"sse"`: Server-Sent Events over HTTP
  - `"http"`: HTTP/HTTPS connection
  - `"passthrough"`: Identity morphism handled locally by agent (no network call)

- `endpoint` (string, required): Connection endpoint
  - For stdio: command to execute (e.g., `"npx @modelcontextprotocol/server-filesystem /path"`)
  - For sse/http: URL (e.g., `"https://example.com/mcp"`)
  - For passthrough: empty string or omitted

- `auth` (object, required): Authentication requirements
  - `type` (string, required): Authentication method
  - `required` (boolean, required): Whether authentication is mandatory
  - `details` (object, optional): Auth-specific configuration

- `headers` (object, optional): HTTP header requirements
  - `required` (array): List of required header names
  - `optional` (object): Optional headers with default values

- `protocol` (object, required): Protocol specification
  - `type` (string, required): Protocol type
  - `version` (string, optional): Protocol version
  - `methods` (array, optional): Available methods/endpoints

- `session` (object, optional): Session requirements
  - `required` (boolean): Whether session initialization is needed
  - `initialization` (object): Session initialization details

#### 4.3.4 Authentication Type Details:

**none:**
```json
{
  "type": "none",
  "required": false,
  "details": {
    "notes": "No authentication needed"
  }
}
```

**bearer:**
```json
{
  "type": "bearer",
  "required": true,
  "details": {
    "instructions_url": "https://example.com/docs/auth",
    "credential_source": "env:API_TOKEN",
    "header_format": "Bearer {token}"
  }
}
```

**api_key:**
```json
{
  "type": "api_key",
  "required": true,
  "details": {
    "location": "header" | "query",
    "param_name": "X-API-Key",
    "format": "{key}",
    "instructions_url": "https://example.com/docs/api-keys",
    "credential_source": "env:API_KEY",
    "registration_url": "https://example.com/signup"
  }
}
```

**oauth2:**
```json
{
  "type": "oauth2",
  "required": true,
  "details": {
    "flow": "authorization_code" | "client_credentials",
    "auth_url": "https://example.com/oauth/authorize",
    "token_url": "https://example.com/oauth/token",
    "scopes": ["read", "write"],
    "pkce_required": true,
    "instructions_url": "https://example.com/docs/oauth",
    "credential_source": "oauth_provider:example"
  }
}
```

**x402:**
```json
{
  "type": "x402",
  "required": true,
  "details": {
    "network": "base-sepolia",
    "asset": "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
    "currency": "USDC",
    "recipient": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
    "price_per_call": 100000
  }
}
```

#### 4.3.5 Example: C_cap-Compliant Financial Tool

```json
{
  "v": 3,
  "t": "semantic_discover",
  "ts": 1735000000,
  "sid": "finadv-mcp",
  "tool": "financial_advisor",
  "signature": {
    "input": "JSON",
    "output": "Maybe<JSON>",
    "cost": 10
  },
  "does": "Provides SEC-compliant investment advice",
  "when": ["investment advice", "portfolio analysis", "financial planning"],
  "good_at": ["SEC compliance", "risk assessment", "tax optimization"],
  "bad_at": ["real-time trading", "crypto speculation"],
  "connector": {
    "transport": "http",
    "endpoint": "https://finadvice.ai/mcp",
    "auth": {
      "type": "oauth2",
      "required": true,
      "details": {
        "flow": "authorization_code",
        "auth_url": "https://finadvice.ai/oauth/authorize",
        "token_url": "https://finadvice.ai/oauth/token",
        "scopes": ["financial:read", "financial:advise"],
        "instructions_url": "https://finadvice.ai/docs/authentication",
        "pkce_required": true
      }
    },
    "headers": {
      "required": ["Accept", "Content-Type"],
      "optional": {
        "Accept": "application/json",
        "Content-Type": "application/json"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    },
    "session": {
      "required": false
    }
  },
  "proven_by": {
    "uses": 5420,
    "success_rate": 0.98
  }
}
```

#### 4.3.6 Example: Identity Morphism

```json
{
  "v": 3,
  "t": "semantic_discover",
  "ts": 1735000000,
  "sid": "dcap-core",
  "tool": "id_Text",
  "signature": {
    "input": "Text",
    "output": "Text",
    "cost": 0
  },
  "identity": true,
  "does": "Identity function for Text type",
  "when": ["passthrough", "no-op"],
  "connector": {
    "transport": "passthrough",
    "endpoint": "",
    "auth": {
      "type": "none",
      "required": false
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05"
    }
  }
}
```

**Identity Morphism Requirements:**

1. `signature.input` MUST equal `signature.output`
2. `signature.cost` MUST be 0
3. Output MUST be byte-identical to input
4. `identity` field MUST be `true`

**Implicit Identity:**

For any type A in the registry, agents MAY assume the existence of an implicit identity morphism `id_A` with cost 0 and passthrough semantics, even if no tool explicitly advertises it. This ensures the category laws hold even when identity tools are not explicitly registered.

#### 4.3.7 Example: Local Tool

```json
{
  "v": 3,
  "t": "semantic_discover",
  "ts": 1735000000,
  "sid": "filesystem-local",
  "tool": "read_file",
  "signature": {
    "input": "Text",
    "output": "Maybe<Text>",
    "cost": 1
  },
  "does": "Reads file contents from local filesystem",
  "when": ["need file contents", "read configuration"],
  "good_at": ["large files", "multiple encodings"],
  "bad_at": ["remote files", "binary files"],
  "connector": {
    "transport": "stdio",
    "endpoint": "npx @modelcontextprotocol/server-filesystem /workspace",
    "auth": {
      "type": "none",
      "required": false,
      "details": {
        "notes": "Local filesystem access, no authentication needed"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    },
    "session": {
      "required": false
    }
  },
  "proven_by": {
    "uses": 8472,
    "success_rate": 0.99
  }
}
```

### 4.4 Performance Update Message (`t: "perf_update"`)
Reports tool execution performance from the tool's perspective (self-report).

**Broadcast by:** Tools (MCP servers)

```json
{
  "v": 3,
  "t": "perf_update",
  "ts": 1727100286,
  "sid": "abc123def456",
  "tool": <tool_name>,
  "exec_ms": <execution_time>,
  "success": <boolean>,
  "cost_paid": <number>,
  "currency": <string>,
  "ctx": <context_object>
}
```

#### Field Specifications:
- `tool` (string, required): Tool identifier matching `semantic_discover`
- `exec_ms` (number, required): Execution time in milliseconds
- `success` (boolean, required): Whether execution succeeded
- `cost_paid` (number, optional): Cost incurred (if applicable)
- `currency` (string, optional): Currency denomination (e.g., "USDC", "USD")
- `ctx` (object, optional): Execution context

#### Context Object (`ctx`):
```json
"ctx": {
  "caller": <caller_identifier>,
  "payer": <payer_address>,
  "args": <sanitized_arguments>,
  "invocation_id": <uuid>
}
```

**Privacy Note:** The `ctx.args` field SHOULD be sanitized to remove sensitive information before broadcasting.

**Cost Consistency:** Tools SHOULD report `cost_paid` equal to their declared `signature.cost`. Persistent deviation MAY be flagged by agents and intelligence systems.

#### Example:
```json
{
  "v": 3,
  "t": "perf_update",
  "ts": 1735000000,
  "sid": "finadv-mcp",
  "tool": "financial_advisor",
  "exec_ms": 245,
  "success": true,
  "cost_paid": 10,
  "currency": "USDC",
  "ctx": {
    "caller": "agent-alice",
    "payer": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1",
    "args": {
      "portfolio_type": "aggressive",
      "risk_tolerance": "medium"
    },
    "invocation_id": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

### 4.5 Usage Receipt Message (`t: "usage_receipt"`)
Reports tool execution performance from the agent's perspective (third-party observation).

**Broadcast by:** Agents (tool consumers)

**Purpose:** Enables agents to share their observations of tool behavior, providing third-party data alongside tool self-reports. Intelligence systems MAY use this data for reputation calculation, comparison with tool claims, or other analytical purposes.

```json
{
  "v": 3,
  "t": "usage_receipt",
  "ts": <unix_timestamp>,
  "agent_id": "<agent_identifier>",
  "tool": "<tool_name>",
  "tool_sid": "<tool_server_id>",
  "success": <boolean>,
  "exec_ms": <number>,
  "cost_paid": <number>,
  "currency": "<string>",
  "payment_proof": "<string>",
  "invocation_id": "<uuid>",
  "error_observed": "<string>",
  "ctx": <object>,
  "blockchain_registrations": [<array>]
}
```

#### Required Fields:
- `v` (number): Protocol version (2)
- `t` (string): Message type ("usage_receipt")
- `ts` (number): Unix timestamp when observation was made
- `agent_id` (string): Agent identifier (8-32 chars, unique per agent)
- `tool` (string): Name of tool being reported on
- `tool_sid` (string): Server identifier of tool (from `semantic_discover`)
- `success` (boolean): Whether invocation succeeded (agent's observation)
- `exec_ms` (number): Execution time in milliseconds (agent's measurement)

#### Optional Fields:
- `cost_paid` (number): Actual cost paid by agent (if applicable)
- `currency` (string): Currency denomination (e.g., "USDC", "USD")
- `payment_proof` (string): Transaction hash or receipt identifier
- `invocation_id` (string): UUID linking to specific invocation
- `error_observed` (string): Error message if failure occurred
- `ctx` (object): Additional context about the observation
- `blockchain_registrations` (array): Agent's blockchain identity registrations

#### Blockchain Registration Object:
When agents include blockchain registration, they use this structure to link their DCAP identity to on-chain identity (e.g., ERC-8004):

```json
"blockchain_registrations": [
  {
    "agentId": <number>,
    "agentRegistry": "eip155:<chainId>:<registryAddress>",
    "tokenURI": "<ipfs_or_http_uri>",
    "verification_url": "<explorer_url>"
  }
]
```

**Blockchain Registration Field Details:**
- `agentId` (number, required): Agent identifier within the registry (ERC-721 tokenId per ERC-8004)
- `agentRegistry` (string, required): Combined format per ERC-8004: `"eip155:<chainId>:<registryAddress>"`
  - Example: `"eip155:1:0xabcd..."` for Ethereum mainnet
  - Example: `"eip155:8453:0x1234..."` for Base
- `tokenURI` (string, optional): URI to agent registration file (IPFS or HTTPS per ERC-8004)
- `verification_url` (string, optional): Human-readable verification link (e.g., block explorer NFT page)

**Note on ERC-8004 Compatibility:**
This format follows ERC-8004 (Trustless Agents) standard. The `agentRegistry` field uses ERC-8004's combined format `"eip155:<chainId>:<registryAddress>"` where the registry is an ERC-721 contract with URIStorage extension. The `agentId` corresponds to the ERC-721 tokenId.

Intelligence systems MAY use blockchain registrations to verify agent identity and weight observations accordingly. The protocol does not prescribe how this verification or weighting should be performed.

#### Example: Agent Report with Blockchain Identity
```json
{
  "v": 3,
  "t": "usage_receipt",
  "ts": 1735000000,
  "agent_id": "agent-alice-001",
  "tool": "financial_advisor",
  "tool_sid": "finadv-mcp",
  "success": false,
  "exec_ms": 5243,
  "cost_paid": 10,
  "currency": "USDC",
  "payment_proof": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",
  "invocation_id": "550e8400-e29b-41d4-a716-446655440000",
  "error_observed": "timeout after 5s waiting for response",
  "ctx": {
    "request_type": "portfolio_analysis",
    "retry_count": 2
  },
  "blockchain_registrations": [
    {
      "agentId": 789,
      "agentRegistry": "eip155:1:0xabcdefabcdefabcdefabcdefabcdefabcdefabcd",
      "tokenURI": "ipfs://QmXyZ123...",
      "verification_url": "https://etherscan.io/nft/0xabcdefabcdefabcdefabcdefabcdefabcdefabcd/789"
    }
  ]
}
```

#### Example: Simple Agent Report
```json
{
  "v": 3,
  "t": "usage_receipt",
  "ts": 1735000000,
  "agent_id": "agent-bob",
  "tool": "read_file",
  "tool_sid": "filesystem-local",
  "success": true,
  "exec_ms": 12,
  "cost_paid": 1
}
```

### 4.6 Composite Capability Message (`t: "composite_capability"`) — NEW in v3.1
Declares a verified composition of tools forming a pipeline.

**Broadcast by:** Agents

**Purpose:** Enables agents to declare tool chains that have been verified for type compatibility and cost consistency. Other agents can reuse declared compositions.

```json
{
  "v": 3,
  "t": "composite_capability",
  "ts": <unix_timestamp>,
  "agent_id": "<agent_identifier>",
  "composite_id": "<unique_composition_id>",
  "chain": [
    {
      "tool_sid": "<tool_server_id>",
      "tool": "<tool_name>",
      "signature": {
        "input": "<input_type>",
        "output": "<output_type>",
        "cost": <cost_value>
      }
    }
  ],
  "signature": {
    "input": "<composite_input_type>",
    "output": "<composite_output_type>",
    "cost": <total_cost>
  }
}
```

#### Required Fields:

| Field | Type | Description |
|-------|------|-------------|
| `agent_id` | string | Declaring agent's identifier |
| `composite_id` | string | Unique identifier for this composition |
| `chain` | array | Ordered list of morphisms to compose |
| `chain[].tool_sid` | string | Tool's server identifier |
| `chain[].tool` | string | Tool name |
| `chain[].signature` | object | Tool's signature (copied from discovery) |
| `signature` | object | Composite signature |
| `ts` | integer | Unix timestamp |

#### Validation Rules:

Agents and hubs MUST validate composite capabilities before accepting or relaying:

1. **Chain continuity**: For each adjacent pair (i, i+1):
   ```
   chain[i].signature.output == chain[i+1].signature.input
   ```

2. **Endpoint agreement**:
   ```
   signature.input == chain[0].signature.input
   signature.output == chain[n-1].signature.output
   ```

3. **Cost additivity**:
   ```
   signature.cost == sum(chain[i].signature.cost)
   ```

4. **Non-empty chain**: `chain.length >= 1`

Invalid compositions MUST be rejected. Hubs SHOULD NOT relay invalid `composite_capability` messages.

#### Single-Tool Compositions:

A composition with `chain.length == 1` is valid and represents the tool itself. This is useful for uniformity — all capabilities (atomic or composite) can be referenced by `composite_id`.

#### Example: URL to German Summary Pipeline

```json
{
  "v": 3,
  "t": "composite_capability",
  "ts": 1735000000,
  "agent_id": "agent-alice",
  "composite_id": "alice-url-to-german-summary",
  "chain": [
    {
      "tool_sid": "fetcher-mcp",
      "tool": "fetch_url",
      "signature": {"input": "URL", "output": "Maybe<HTML>", "cost": 2}
    },
    {
      "tool_sid": "extractor-mcp",
      "tool": "html_to_text",
      "signature": {"input": "HTML", "output": "Maybe<Text>", "cost": 1}
    },
    {
      "tool_sid": "summary-mcp",
      "tool": "summarize",
      "signature": {"input": "Text", "output": "Maybe<Text>", "cost": 5}
    },
    {
      "tool_sid": "translate-mcp",
      "tool": "translate_en_de",
      "signature": {"input": "Text", "output": "Maybe<Text>", "cost": 3}
    }
  ],
  "signature": {
    "input": "URL",
    "output": "Maybe<Text>",
    "cost": 11
  }
}
```

**Note on Effect Types:** This example shows tools returning `Maybe<T>`. In v3.1, agents handle unwrapping between steps. Kleisli composition (automatic `Maybe` propagation) is planned for v3.2.

### 4.7 Composite Receipt Message (`t: "composite_receipt"`) — NEW in v3.1
Reports execution of a composition with per-step metrics.

**Broadcast by:** Agents

**Purpose:** Provides full auditability of composition execution, enabling verification that costs and timing match declarations.

```json
{
  "v": 3,
  "t": "composite_receipt",
  "ts": <unix_timestamp>,
  "agent_id": "<agent_identifier>",
  "composite_id": "<composition_reference>",
  "success": <boolean>,
  "exec_ms": <total_execution_time>,
  "cost_paid": <total_cost>,
  "currency": "<string>",
  "steps": [
    {
      "tool_sid": "<tool_server_id>",
      "tool": "<tool_name>",
      "success": <boolean>,
      "exec_ms": <step_execution_time>,
      "cost_paid": <step_cost>,
      "error": "<error_message_if_failed>"
    }
  ]
}
```

#### Required Fields:

| Field | Type | Description |
|-------|------|-------------|
| `agent_id` | string | Executing agent's identifier |
| `composite_id` | string | Reference to declared composition |
| `success` | boolean | Overall success (all steps succeeded) |
| `exec_ms` | integer | Total execution time |
| `cost_paid` | integer | Total cost paid |
| `steps` | array | Per-step execution data |
| `steps[].tool_sid` | string | Tool's server identifier |
| `steps[].tool` | string | Tool name |
| `steps[].success` | boolean | Step success |
| `steps[].exec_ms` | integer | Step execution time |
| `steps[].cost_paid` | integer | Step cost |
| `ts` | integer | Unix timestamp |

#### Optional Fields:

| Field | Type | Description |
|-------|------|-------------|
| `currency` | string | Currency of cost |
| `steps[].error` | string | Error message if step failed |

#### Example: Successful Execution

```json
{
  "v": 3,
  "t": "composite_receipt",
  "ts": 1735000100,
  "agent_id": "agent-alice",
  "composite_id": "alice-url-to-german-summary",
  "success": true,
  "exec_ms": 1847,
  "cost_paid": 11,
  "currency": "USDC",
  "steps": [
    {"tool_sid": "fetcher-mcp", "tool": "fetch_url", "success": true, "exec_ms": 342, "cost_paid": 2},
    {"tool_sid": "extractor-mcp", "tool": "html_to_text", "success": true, "exec_ms": 89, "cost_paid": 1},
    {"tool_sid": "summary-mcp", "tool": "summarize", "success": true, "exec_ms": 1203, "cost_paid": 5},
    {"tool_sid": "translate-mcp", "tool": "translate_en_de", "success": true, "exec_ms": 213, "cost_paid": 3}
  ]
}
```

#### Failure Handling:

If any step fails, the composition fails. The receipt SHOULD include:
- `success: false` at top level
- `steps` up to and including the failed step
- `error` field on the failed step

```json
{
  "v": 3,
  "t": "composite_receipt",
  "ts": 1735000100,
  "agent_id": "agent-alice",
  "composite_id": "alice-url-to-german-summary",
  "success": false,
  "exec_ms": 431,
  "cost_paid": 3,
  "currency": "USDC",
  "steps": [
    {"tool_sid": "fetcher-mcp", "tool": "fetch_url", "success": true, "exec_ms": 342, "cost_paid": 2},
    {"tool_sid": "extractor-mcp", "tool": "html_to_text", "success": false, "exec_ms": 89, "cost_paid": 1, "error": "Malformed HTML: unclosed <div> tag"}
  ]
}
```

### 4.8 Error Pattern Message (`t: "error_pattern"`)
Reports recurring error patterns for proactive error handling.

**Broadcast by:** Tools (MCP servers)

```json
{
  "v": 3,
  "t": "error_pattern",
  "ts": 1727100286,
  "sid": "abc123def456",
  "tool": <tool_name>,
  "error_type": <error_classification>,
  "frequency": <occurrence_count>,
  "sample_args": <sanitized_arguments>,
  "mitigation": <suggested_fix>
}
```

#### Field Specifications:
- `tool` (string, required): Tool identifier
- `error_type` (string, required): Error classification
- `frequency` (number, required): Occurrence count in recent window
- `sample_args` (object, optional): Sanitized sample of problematic arguments
- `mitigation` (string, optional): Suggested mitigation strategy

## 5. Composition Semantics

### 5.1 Notation

For morphisms f : A → B and g : B → C, the composition g ∘ f : A → C is executed as:

```
input : A
  │
  ▼
  f
  │
  ▼
intermediate : B
  │
  ▼
  g
  │
  ▼
output : C
```

### 5.2 Execution Order

Composition is **left-to-right** in the `chain` array but **right-to-left** in mathematical notation:

```
chain: [f, g, h]
mathematical: h ∘ g ∘ f
execution: f → g → h
```

The `chain` array represents execution order: `chain[0]` runs first.

### 5.3 Associativity Guarantee

By the associativity law, these are equivalent:

```
(h ∘ g) ∘ f  =  h ∘ (g ∘ f)  =  h ∘ g ∘ f
```

Agents MAY restructure compositions for optimization (e.g., batching, parallel execution of independent subchains) as long as the sequential semantics are preserved.

### 5.4 Partial Composition

Agents MAY compose subsets of a chain. Given:

```
chain: [f, g, h, i]
```

An agent MAY create intermediate compositions:

```
composite_1: [f, g]      → A → C
composite_2: [h, i]      → C → E
composite_3: [composite_1, composite_2]  → A → E
```

Nested compositions MUST be flattened for validation — the cost law applies to the fully expanded chain.

### 5.5 Effect Type Handling (v3.1)

In v3.1, compositions involving `Maybe<T>` or other effect types require explicit handling:

1. Agent executes step i, receives `Maybe<T>`
2. If `Nothing`/failure, composition fails
3. If `Just t`, unwrap and pass `t` to step i+1

**Planned for v3.2:** Kleisli composition will automate this unwrapping, allowing `A → Maybe<B>` and `B → Maybe<C>` to compose directly into `A → Maybe<C>`.

## 6. Transport Protocol Requirements

### 6.1 UDP Advertisement Protocol
- **Port**: 10191
- **Packet Size**: MUST NOT exceed 1472 bytes (avoid fragmentation)
- **Encoding**: UTF-8 JSON
- **Reliability**: Best effort delivery (fire-and-forget)

### 6.2 Size Management
If message exceeds 1400 bytes, implementations SHOULD truncate in this priority order:

1. Omit `ctx` object (for `perf_update`, `usage_receipt`, `composite_receipt`)
2. Omit `blockchain_registrations` array (for `usage_receipt`)
3. Omit `steps` array details (for `composite_receipt`, keep only summary)
4. Omit `connector.session` object
5. Omit `connector.headers.optional` object
6. Omit `connector.protocol.methods` array
7. Truncate `auth.details.instructions_url` to domain only
8. Omit `auth.details.registration_url`
9. Keep: `tool`, `signature`, `connector.transport`, `connector.endpoint`, `connector.auth.type`, `connector.auth.required`

### 6.3 WebSocket Distribution Protocol  
- **Upgrade Protocol**: HTTP/1.1 WebSocket upgrade
- **Subprotocol**: `dcap-v2`
- **Message Format**: JSON text frames
- **Heartbeat**: PING/PONG every 30 seconds

## 7. Discovery Algorithm

### 7.1 Agent Discovery Process
```
1. Agent receives task request
2. Parse semantic intent from request
3. Query accumulated tool knowledge base
4. Match intent against tool descriptions using:
   a. Direct keyword matching in 'when' array
   b. Semantic similarity scoring on 'does' field  
   c. Capability intersection with 'good_at' array
   d. Type compatibility via 'signature' field (v3.1)
5. Rank candidates by:
   a. Type compatibility (C_cap-compliant preferred for compositions)
   b. proven_by.success_rate (reliability)
   c. Average exec_ms (speed)
   d. signature.cost (for C_cap tools) or average cost_paid (economic efficiency)
   e. Auth complexity (prefer 'none' > 'api_key' > 'bearer' > 'oauth2')
6. Extract connector details from selected tool:
   a. Parse transport type and endpoint
   b. Check authentication requirements and available credentials
   c. Verify required headers can be provided
   d. Prepare session initialization if needed
   e. Establish connection according to protocol type
7. Execute task with acquired capability
8. Broadcast usage_receipt with observed performance
9. If part of composition, track for composite_receipt
```

**Note:** The ranking criteria listed above are suggestions. Agents MAY implement any ranking algorithm appropriate for their use case.

### 7.2 Semantic Matching Requirements
Implementations SHOULD support:
- Exact string matching for triggers
- Fuzzy string matching (edit distance < 3)
- Semantic similarity scoring (cosine similarity > 0.7)

### 7.3 Composition Planning (NEW in v3.1)

When planning a composition from type A to type Z:

1. Build a graph of available morphisms from C_cap-compliant discovered tools
2. Nodes are types (from registry)
3. Edges are tools with their signatures
4. Edge weights are `signature.cost`
5. Find paths from A to Z using graph search (Dijkstra for cost minimization)
6. Select path based on criteria (cost, reliability, speed)
7. Validate the path forms a valid composition (type continuity, cost additivity)
8. Broadcast `composite_capability`
9. Execute steps sequentially
10. Broadcast `composite_receipt`

### 7.4 Chain Pattern Detection
Intelligence systems MAY:
- Track sequences of tool invocations from `composite_receipt` messages
- Identify commonly chained tools
- Recommend tool chains for complex tasks
- Cache validated compositions for reuse

### 7.5 Economic Efficiency Optimization
Intelligence systems MAY:
- Track cost trends over time
- Compare declared `signature.cost` against actual `cost_paid`
- Identify cost-effective alternatives
- Recommend tools with best price/performance ratio
- Detect tools whose actual costs deviate from declared costs

### 7.6 Dynamic Tool Acquisition
Agents SHOULD:
- Parse `connector` object to determine connection method
- Support multiple transport types or gracefully skip unsupported tools
- Validate endpoints before attempting connection
- Handle authentication flows or prompt users with `instructions_url`

## 8. Security Considerations

### 8.1 Denial of Service Protection
Intelligence hubs SHOULD implement:
- Rate limiting per `sid` and `agent_id`
- Message validation before distribution
- Duplicate message detection
- Malformed message rejection
- Composition validation before relay (v3.1)

### 8.2 Capability Validation
Agents MUST:
- Validate tool endpoints before connection
- Sandbox unknown tools during initial execution
- Monitor tool behavior for anomalies
- Verify TLS certificates for `https://` endpoints
- For `stdio` transport, validate commands are from trusted sources
- Validate OAuth redirect URIs match `auth_url` domain
- Never execute stdio commands with user-controlled input

### 8.3 Composition Validation (NEW in v3.1)
Agents and hubs MUST:
- Validate type continuity before accepting compositions
- Validate cost additivity before relaying
- Reject compositions that violate category laws
- Track composition success rates per declaring agent

### 8.4 Privacy Considerations

#### 8.4.1 Argument Sanitization
Tools broadcasting `perf_update` and agents broadcasting `usage_receipt` or `composite_receipt` SHOULD:
- Sanitize `ctx.args` to remove sensitive information
- Replace sensitive values with type indicators (e.g., `"<email>"`, `"<token>"`)
- Never broadcast credentials, passwords, or API keys
- Omit `ctx` entirely if sanitization is uncertain

#### 8.4.2 Cost Data Transparency
- `cost_paid` and `currency` fields provide transparency
- Agents can compare declared `signature.cost` against actual charges
- Economic data enables market-driven tool selection

#### 8.4.3 Endpoint Security
Tools SHOULD:
- Use HTTPS for `http` transport endpoints
- Validate TLS certificates
- Provide clear authentication instructions
- Support secure credential acquisition methods
- Use environment variables or secure vaults for credential storage

#### 8.4.4 OAuth Security
OAuth implementations MUST:
- Validate redirect URIs
- Implement PKCE when `pkce_required: true`
- Never expose client secrets in broadcast messages
- Provide secure token storage recommendations
- Implement proper scope validation

#### 8.4.5 Blockchain Verification Security
When verifying agent blockchain registrations, intelligence systems SHOULD:
- Verify registry contract address matches known registries
- Confirm chain_id matches expected network
- Query on-chain data to validate agent_id exists
- Check for revocation or expiration status
- Validate metadata_uri content if used

**Warning:** Blockchain registration provides identity anchoring but does not guarantee agent honesty. Intelligence systems should still validate observation consistency and detect anomalous reporting patterns.

### 8.5 Type Spoofing (NEW in v3.1)
A malicious tool could declare a false signature (e.g., claim `Text → Text` but actually return `Binary`). Mitigations:
- Agents SHOULD validate output types match declarations
- Agents SHOULD report type mismatches in `usage_receipt`
- Reputation systems SHOULD penalize type violators

### 8.6 Cost Manipulation (NEW in v3.1)
A tool could declare low cost but charge more. Mitigations:
- Agents report `cost_paid` in receipts
- Agents SHOULD flag tools where `cost_paid` > declared `signature.cost`
- Reputation systems SHOULD track cost accuracy

### 8.7 Composition Bombs (NEW in v3.1)
A malicious agent could broadcast expensive compositions to waste hub resources. Mitigations:
- Hubs MAY rate-limit `composite_capability` broadcasts
- Hubs MAY require proof-of-stake for composition registration
- Hubs MAY limit maximum chain length

## 9. Implementation Guidelines  

### 9.1 Tool Provider Requirements
Tools implementing DCAP MUST:
- Generate unique, stable server identifiers (`sid`)
- Broadcast `semantic_discover` on first capability use with complete `connector` details
- Include comprehensive auth details per specification
- Specify all required HTTP headers in `connector.headers`
- Document session initialization requirements if applicable
- Respect UDP packet size limits (prioritize critical fields)

Tools implementing DCAP SHOULD:
- Include `signature` field for C_cap compliance (v3.1)
- Use honest type declarations (use `Maybe<T>` for fallible tools)
- Report `signature.cost` that matches actual charges
- Send `perf_update` messages for significant events
- Sanitize arguments before including in `ctx.args`
- Report actual cost charged in `cost_paid` when applicable
- Ensure `connector.endpoint` is reachable from agent networks
- Keep authentication requirements current in `connector.auth`
- Provide valid `instructions_url` for credential acquisition

Tools implementing DCAP MAY:
- Broadcast `error_pattern` messages for recurring issues
- Include additional context in `ctx` fields
- Provide registration URLs for credential acquisition
- Provide explicit identity morphisms for their types

### 9.2 Agent Consumer Requirements  
Agents implementing DCAP MUST:
- Maintain local capability knowledge base
- Handle UDP packet loss gracefully
- Implement connection retry logic for tool acquisition
- Validate tool responses before use
- Parse and validate `connector` information before attempting connection
- Implement secure credential storage for auth tokens
- Support multiple transport types or gracefully skip unsupported tools

Agents implementing DCAP SHOULD:
- Prefer C_cap-compliant tools for compositions (v3.1)
- Validate `signature` type compatibility before composing
- Validate cost additivity before broadcasting compositions
- Broadcast `composite_capability` before executing chains (v3.1)
- Broadcast `composite_receipt` after chain execution (v3.1)
- Broadcast `usage_receipt` after tool invocations
- Report actual observed performance (what was measured)
- Include `cost_paid` if payment occurred
- Sanitize or omit sensitive information from `ctx`
- Handle OAuth flows or prompt users with `instructions_url`
- Respect `headers.required` when making HTTP requests
- Implement session initialization per `session` specification
- Check credential availability before attempting tool calls

Agents implementing DCAP MAY:
- Include `blockchain_registrations` for identity anchoring
- Choose which invocations to report (not required to report all)
- Include additional context in `ctx` field
- Include `invocation_id` for detailed tracking
- Cache and reuse validated compositions from other agents
- Optimize composition execution (batching, parallelization)

### 9.3 Hub Implementation Requirements
Intelligence hubs implementing DCAP MUST:
- Listen on UDP port 10191 for broadcasts
- Validate message format before distribution
- Distribute messages via WebSocket with `dcap-v2` subprotocol
- Implement rate limiting per `sid` and `agent_id`
- Handle malformed messages gracefully

Intelligence hubs implementing DCAP SHOULD:
- Validate `composite_capability` messages for categorical correctness (v3.1)
- Reject compositions that violate type continuity or cost additivity
- Maintain message history for late-joining agents
- Implement duplicate message detection
- Track tool availability and broadcast status
- Provide query interfaces for capability search

Intelligence hubs implementing DCAP MAY:
- Calculate aggregate statistics (e.g., `proven_by` metrics)
- Compare `perf_update` (tool claims) vs `usage_receipt` (agent observations)
- Weight observations by agent blockchain verification status
- Detect and flag discrepancies between tool self-reports and agent observations
- Implement any reputation or trust algorithms appropriate for their use case
- Index tools by `signature.input` and `signature.output` for composition queries
- Maintain a type graph for path finding

**Note:** The protocol does not prescribe how hubs calculate reputation metrics. Hubs are free to implement any algorithm using the available message data.

### 9.4 Intelligence Consumer Requirements
Systems consuming DCAP streams (e.g., Oracle agents) SHOULD:
- Track message sequences by `sid` and `agent_id` for pattern detection
- Maintain statistical models of tool performance
- Respect privacy constraints when analyzing `ctx` fields
- Index tools by `connector.transport` for transport-specific recommendations
- Track authentication requirements to inform agents of access needs
- Classify tools by `auth.type` complexity for smart recommendations
- Build type graphs from `signature` fields for composition planning (v3.1)

Systems consuming DCAP streams MAY:
- Implement any reputation or ranking algorithm using message data
- Correlate tool self-reports with agent observations
- Weight agent observations by any criteria (blockchain verification, history, etc.)
- Detect and report anomalous patterns
- Calculate efficiency metrics incorporating time and cost
- Pre-compute optimal compositions for common type transitions

## 10. Future Work

### 10.1 Effectful Composition (Kleisli Categories) — Planned for v3.2

Tools with effects (`Maybe<T>`, `List<T>`, `IO<T>`) compose via Kleisli composition. This is planned for v3.2 and will not require breaking changes.

```
f : A → Maybe<B>
g : B → Maybe<C>
g ∘_kleisli f : A → Maybe<C>
```

**v3.1**: C_cap — pure morphisms, category laws verified  
**v3.2**: C_cap_K — Kleisli extension for effectful morphisms

The `signature` schema and message formats will remain unchanged.

### 10.2 Parallel Composition (Monoidal Categories)

For tools that can run in parallel:

```
f : A → B
g : C → D
f ⊗ g : (A, C) → (B, D)
```

### 10.3 Formal Verification

Machine-checked proofs of categorical laws using proof assistants (Agda, Coq, Lean).

### 10.4 On-Chain Composition Registry

Compositions registered on-chain for immutable audit trails and trustless verification.

## 11. References

### 11.1 Normative References
- [RFC2119] Key words for use in RFCs
- [RFC6455] The WebSocket Protocol  
- [RFC768] User Datagram Protocol
- [RFC6749] OAuth 2.0 Authorization Framework
- [RFC7636] Proof Key for Code Exchange (PKCE)
- [MCP] Model Context Protocol Specification

### 11.2 Informative References
- [AutoGPT] Autonomous GPT-4 Experiment
- [LangChain] Framework for developing applications with LLMs
- [x402] x402 Micropayment Protocol
- [EIP-155] Ethereum Chain ID Specification
- [ERC-8004] ERC-8004: Trustless Agents - Discover agents and establish trust through reputation and validation (draft)
- [C_cap] Capability Categories in DCAP - Category theory foundation (Maurer, 2025)

## 12. Changelog

### Version 3.1 (December 2025)

**Added:**
- Categorical foundation (C_cap) with formal category laws
- `signature` field in `semantic_discover` for typed morphisms
- `identity` flag for identity morphisms
- Type registry with core types and effect types
- `composite_capability` message type for verified compositions
- `composite_receipt` message type for composition execution reporting
- Composition validation rules (type continuity, cost additivity)
- Composition semantics (execution order, associativity, partial composition)
- Composition planning algorithm
- Security considerations for type spoofing, cost manipulation, composition bombs
- `passthrough` transport type for identity morphisms

**Changed:**
- Discovery algorithm updated to include type compatibility matching
- Size management priority updated to include composition messages
- Security section expanded with categorical compliance considerations
- Implementation guidelines updated for C_cap compliance

**Rationale:**
- Formal categorical foundation enables verified composition
- Typed signatures allow agents to validate chains before execution
- Cost enrichment law ensures predictable pricing
- Effect types (Maybe, List, IO) make fallibility explicit
- Maintains full backward compatibility with v3.0

### Version 3.0 (December 2025)
**Added:**
- New message type: `usage_receipt` for agent-reported observations
- `agent_id` field for agent message identification
- `blockchain_registrations` array for agent identity anchoring (in `usage_receipt`)
- Distinction between tool self-reports and agent observations
- Guidelines for agent verification broadcasting
- Security considerations for blockchain verification

**Changed:**
- Clarified that `perf_update` is a tool self-report
- Specified that `proven_by` calculation is implementation-specific (not prescribed by protocol)
- Updated security section to address agent identity verification

**Removed:**
- `blockchain_registrations` from `semantic_discover` (corrected architectural error from v2.7)

**Rationale:**
- Version 2.7 incorrectly placed `blockchain_registrations` in tool messages (`semantic_discover`)
- Tools (MCP servers) are not agents - they are identified by `sid`
- Blockchain registration (ERC-8004) is for agent identity, not tool identity
- v3.0 corrects this by moving blockchain registration to agent messages (`usage_receipt`)
- Adding `usage_receipt` enables third-party verification: agents report what they observe, tools report what they claim
- Intelligence systems can now compare tool claims against agent observations
- The protocol remains pure: it defines message formats, not trust algorithms

### Version 2.7 (November 2025)
- Added `blockchain_registrations` to `semantic_discover` (architectural error, corrected in v3.0)
- Introduced two-tier architecture concept (DCAP + blockchain)

### Version 2.6 (November 2025)
- Enhanced `connector` object with comprehensive authentication details
- Added OAuth2, bearer, api_key, and x402 authentication types
- Added `headers` specification for HTTP requests
- Added `session` initialization requirements
- Enabled truly autonomous tool acquisition

### Version 2.5 (October 2025)
- Introduced `connector` object for connection automation
- Added transport types: stdio, sse, http
- Added basic authentication specification

### Version 2.4 (October 2025)
- Enhanced security considerations
- Added credential management guidelines

### Version 2.3 (October 2025)
- Added pattern detection capabilities
- Enhanced discovery algorithm

### Version 2.2 (October 2025)
- Added cost tracking: `cost_paid` and `currency` fields
- Enabled economic efficiency optimization

### Version 2.1 (October 2025)
- Added context tracking: `ctx` field in `perf_update`
- Added `invocation_id` for message correlation
- Enhanced privacy considerations

### Version 2.0 (September 2025)
- Initial public specification
- Core message types: `semantic_discover`, `perf_update`, `error_pattern`
- UDP and WebSocket transport protocols
- Basic discovery algorithm

## Appendix A. Example Agent Implementation

```javascript
// Agent with C_cap Composition Support (v3.1)
class DCAPAgentV31 {
  constructor(agentId, blockchainRegistrations = null) {
    this.agentId = agentId;
    this.blockchainRegistrations = blockchainRegistrations;
    this.knownTools = new Map();
    this.typeGraph = new Map(); // type -> [{tool, signature, sid}]
    
    // Connect to DCAP stream
    this.ws = new WebSocket('ws://hub:10191', 'dcap-v2');
    this.ws.onmessage = this.handleMessage.bind(this);
  }
  
  handleMessage(event) {
    const msg = JSON.parse(event.data);
    
    if (msg.t === 'semantic_discover') {
      this.knownTools.set(msg.tool, msg);
      
      // Build type graph for C_cap-compliant tools
      if (msg.signature) {
        const inputType = msg.signature.input;
        if (!this.typeGraph.has(inputType)) {
          this.typeGraph.set(inputType, []);
        }
        this.typeGraph.get(inputType).push({
          tool: msg.tool,
          sid: msg.sid,
          signature: msg.signature,
          connector: msg.connector
        });
      }
    }
  }
  
  // Find a composition path from inputType to outputType
  findCompositionPath(inputType, outputType) {
    const visited = new Set();
    const queue = [{type: inputType, path: [], cost: 0}];
    
    while (queue.length > 0) {
      // Sort by cost (Dijkstra)
      queue.sort((a, b) => a.cost - b.cost);
      const {type, path, cost} = queue.shift();
      
      if (type === outputType) {
        return path;
      }
      
      if (visited.has(type)) continue;
      visited.add(type);
      
      const edges = this.typeGraph.get(type) || [];
      for (const edge of edges) {
        // Handle Maybe<T> -> T unwrapping for next step
        let nextType = edge.signature.output;
        if (nextType.startsWith('Maybe<')) {
          nextType = nextType.slice(6, -1); // Extract T from Maybe<T>
        }
        
        queue.push({
          type: nextType,
          path: [...path, edge],
          cost: cost + edge.signature.cost
        });
      }
    }
    
    return null; // No path found
  }
  
  // Validate a composition chain
  validateComposition(chain) {
    if (chain.length === 0) return false;
    
    for (let i = 0; i < chain.length - 1; i++) {
      let output = chain[i].signature.output;
      let input = chain[i + 1].signature.input;
      
      // Handle Maybe<T> unwrapping
      if (output.startsWith('Maybe<')) {
        output = output.slice(6, -1);
      }
      
      if (output !== input) {
        console.error(`Type mismatch: ${output} != ${input}`);
        return false;
      }
    }
    
    return true;
  }
  
  // Calculate composite signature
  getCompositeSignature(chain) {
    const input = chain[0].signature.input;
    let output = chain[chain.length - 1].signature.output;
    const cost = chain.reduce((sum, step) => sum + step.signature.cost, 0);
    
    // If any step returns Maybe, composite returns Maybe
    const hasMaybe = chain.some(step => step.signature.output.startsWith('Maybe<'));
    if (hasMaybe && !output.startsWith('Maybe<')) {
      output = `Maybe<${output}>`;
    }
    
    return {input, output, cost};
  }
  
  // Declare and broadcast a composition
  async declareComposition(compositeId, chain) {
    if (!this.validateComposition(chain)) {
      throw new Error('Invalid composition: type mismatch');
    }
    
    const signature = this.getCompositeSignature(chain);
    
    const message = {
      v: 2,
      t: 'composite_capability',
      ts: Math.floor(Date.now() / 1000),
      agent_id: this.agentId,
      composite_id: compositeId,
      chain: chain.map(step => ({
        tool_sid: step.sid,
        tool: step.tool,
        signature: step.signature
      })),
      signature
    };
    
    this.udpBroadcast(message);
    return message;
  }
  
  // Execute a composition and report results
  async executeComposition(compositeId, chain, initialInput) {
    const steps = [];
    let currentInput = initialInput;
    let totalExecMs = 0;
    let totalCost = 0;
    let success = true;
    
    for (const step of chain) {
      const startTime = Date.now();
      
      try {
        const client = await this.connectToTool(step);
        const result = await client.callTool(step.tool, currentInput);
        const execMs = Date.now() - startTime;
        
        steps.push({
          tool_sid: step.sid,
          tool: step.tool,
          success: true,
          exec_ms: execMs,
          cost_paid: step.signature.cost
        });
        
        totalExecMs += execMs;
        totalCost += step.signature.cost;
        
        // Handle Maybe unwrapping
        if (result === null || result === undefined) {
          throw new Error('Tool returned Nothing');
        }
        
        currentInput = result;
        
      } catch (error) {
        const execMs = Date.now() - startTime;
        
        steps.push({
          tool_sid: step.sid,
          tool: step.tool,
          success: false,
          exec_ms: execMs,
          cost_paid: step.signature.cost,
          error: error.message
        });
        
        totalExecMs += execMs;
        totalCost += step.signature.cost;
        success = false;
        break;
      }
    }
    
    // Broadcast composite receipt
    const receipt = {
      v: 2,
      t: 'composite_receipt',
      ts: Math.floor(Date.now() / 1000),
      agent_id: this.agentId,
      composite_id: compositeId,
      success,
      exec_ms: totalExecMs,
      cost_paid: totalCost,
      currency: 'USDC',
      steps
    };
    
    this.udpBroadcast(receipt);
    
    return {success, result: success ? currentInput : null, receipt};
  }
  
  // Invoke a single tool (unchanged from v3.0)
  async invokeTool(toolName, args) {
    const tool = this.knownTools.get(toolName);
    if (!tool) throw new Error(`Tool ${toolName} not found`);
    
    const startTime = Date.now();
    
    try {
      const client = await this.connectToTool(tool);
      const result = await client.callTool(toolName, args);
      const execMs = Date.now() - startTime;
      
      this.broadcastUsageReceipt({
        tool: toolName,
        tool_sid: tool.sid,
        success: true,
        exec_ms: execMs,
        cost_paid: tool.signature?.cost || result.cost,
        currency: result.currency,
        invocation_id: result.invocation_id
      });
      
      return result;
      
    } catch (error) {
      const execMs = Date.now() - startTime;
      
      this.broadcastUsageReceipt({
        tool: toolName,
        tool_sid: tool.sid,
        success: false,
        exec_ms: execMs,
        error_observed: error.message
      });
      
      throw error;
    }
  }
  
  broadcastUsageReceipt(receipt) {
    const message = {
      v: 2,
      t: 'usage_receipt',
      ts: Math.floor(Date.now() / 1000),
      agent_id: this.agentId,
      ...receipt
    };
    
    if (this.blockchainRegistrations) {
      message.blockchain_registrations = this.blockchainRegistrations;
    }
    
    this.udpBroadcast(message);
  }
  
  async connectToTool(tool) {
    const connector = tool.connector || tool;
    const { transport, endpoint, auth, headers } = connector;
    
    if (transport === 'passthrough') {
      // Identity morphism - return input unchanged
      return {
        callTool: (name, input) => input
      };
    }
    
    if (transport === 'stdio') {
      return await this.connectStdio(endpoint);
    } else if (transport === 'sse' || transport === 'http') {
      return await this.connectHttp(endpoint, auth, headers);
    }
    
    throw new Error(`Unsupported transport: ${transport}`);
  }
  
  async connectHttp(endpoint, auth, headers) {
    const authHeaders = await this.prepareAuth(auth);
    
    const allHeaders = {
      ...headers?.optional,
      ...authHeaders
    };
    
    return new MCPHttpClient(endpoint, allHeaders);
  }
  
  async prepareAuth(auth) {
    if (!auth.required || auth.type === 'none') {
      return {};
    }
    
    if (auth.type === 'bearer') {
      const token = await this.getCredential(auth.details.credential_source);
      return {
        'Authorization': auth.details.header_format.replace('{token}', token)
      };
    }
    
    if (auth.type === 'api_key') {
      const key = await this.getCredential(auth.details.credential_source);
      if (auth.details.location === 'header') {
        return {
          [auth.details.param_name]: auth.details.format.replace('{key}', key)
        };
      }
    }
    
    if (auth.type === 'oauth2') {
      const token = await this.handleOAuth2(auth.details);
      return {
        'Authorization': `Bearer ${token}`
      };
    }
    
    if (auth.type === 'x402') {
      const payment = await this.handleX402Payment(auth.details);
      return {
        'X-402-Payment': payment
      };
    }
    
    throw new Error(`Unsupported auth type: ${auth.type}`);
  }
  
  async getCredential(source) {
    if (source.startsWith('env:')) {
      const envVar = source.substring(4);
      return process.env[envVar];
    }
    throw new Error(`Unsupported credential source: ${source}`);
  }
  
  udpBroadcast(message) {
    const json = JSON.stringify(message);
    const buffer = Buffer.from(json, 'utf8');
    
    if (buffer.length > 1472) {
      console.warn('Message exceeds UDP packet size, truncating...');
      // Handle truncation per spec...
    }
    
    // Broadcast via UDP to port 10191
    // Implementation details...
  }
}

// Usage Example
const agent = new DCAPAgentV31('agent-alice', [
  {
    agentId: 789,
    agentRegistry: 'eip155:1:0xabcd...',
    verification_url: 'https://etherscan.io/nft/0xabcd.../789'
  }
]);

// Wait for discovery
await new Promise(resolve => setTimeout(resolve, 2000));

// Find and execute a composition
const path = agent.findCompositionPath('URL', 'Text');
if (path) {
  const compositeId = `${agent.agentId}-url-to-text-${Date.now()}`;
  
  // Declare composition
  await agent.declareComposition(compositeId, path);
  
  // Execute
  const {success, result} = await agent.executeComposition(
    compositeId, 
    path, 
    'https://example.com/article'
  );
  
  console.log('Composition result:', success ? result : 'Failed');
}
```

## Appendix B. Message Size Optimization

Example of handling UDP size constraints:

```javascript
function truncateMessage(message) {
  let json = JSON.stringify(message);
  
  if (json.length <= 1400) {
    return json;
  }
  
  // Priority 1: Remove ctx
  if (message.ctx) {
    delete message.ctx;
    json = JSON.stringify(message);
    if (json.length <= 1400) return json;
  }
  
  // Priority 2: Remove blockchain_registrations
  if (message.blockchain_registrations) {
    delete message.blockchain_registrations;
    json = JSON.stringify(message);
    if (json.length <= 1400) return json;
  }
  
  // Priority 3: Simplify steps (composite_receipt)
  if (message.steps && message.t === 'composite_receipt') {
    message.steps = message.steps.map(s => ({
      tool_sid: s.tool_sid,
      success: s.success
    }));
    json = JSON.stringify(message);
    if (json.length <= 1400) return json;
  }
  
  // Priority 4: Remove connector.session
  if (message.connector?.session) {
    delete message.connector.session;
    json = JSON.stringify(message);
    if (json.length <= 1400) return json;
  }
  
  // Continue with other optimizations...
  
  return json;
}
```

## Appendix C. C_cap Reference Implementation

A reference implementation of C_cap validation in Haskell is available at:

```
https://github.com/boorich/ccap-haskell
```

This implementation includes QuickCheck property tests verifying the category laws:

- Left identity: `id_B ∘ f = f`
- Right identity: `f ∘ id_A = f`
- Associativity: `h ∘ (g ∘ f) = (h ∘ g) ∘ f`
- Cost identity: `cost(id_A) = 0`
- Cost composition: `cost(g ∘ f) = cost(f) + cost(g)`

## Authors' Addresses

Martin Maurer  
Email: empeamtk@googlemail.com