# Dynamic Capability Acquisition Protocol (DCAP)

**Version**: 2.5  
**Date**: October 2025  
**Author**: M. Maurer  

## Abstract

This document defines the Dynamic Capability Acquisition Protocol (DCAP), a decentralized protocol enabling autonomous agents to discover, evaluate, and acquire computational capabilities at runtime through semantic broadcasting. DCAP uses UDP multicast for capability advertisement and WebSocket streams for real-time intelligence distribution.


## 1. Introduction

### 1.1 Problem Statement
Current autonomous agent systems operate with fixed, pre-configured tool sets, limiting their ability to handle novel or specialized tasks. Existing tool discovery mechanisms rely on centralized registries, creating bottlenecks and single points of failure.

### 1.2 Solution Overview
DCAP enables tools to self-advertise their capabilities using semantic descriptions, allowing agents to discover and dynamically load appropriate tools based on task requirements rather than static configuration. Version 2.5 extends capability advertisement with structured connector information, enabling fully autonomous tool acquisition without pre-configuration.

## 2. Protocol Architecture

### 2.1 Network Topology
```
Tool Provider → UDP Broadcast → Intelligence Hub → WebSocket → Agent Consumer
     ^                              ^                   ^           ^
   MCP Tool                   Stream Aggregator    Real-time     Dynamic Agent
                                                                      ↓
                                                            Dynamic Tool Invocation
```

### 2.2 Transport Layers
- **Advertisement Layer**: UDP packets (port 10191)
- **Distribution Layer**: WebSocket streams 
- **Acquisition Layer**: MCP protocol over stdio/HTTP/WebSocket (specified in connector)

## 3. Message Format Specification

### 3.1 Base Message Structure
All DCAP messages MUST conform to this JSON schema:

```json
{
  "v": <protocol_version>,
  "t": <message_type>, 
  "ts": <unix_timestamp>,
  "sid": <server_identifier>,
  [message_specific_fields]
}
```

#### Required Fields:
- `v` (number): Protocol version (current: 2)
- `t` (string): Message type identifier
- `ts` (number): Unix timestamp of message creation
- `sid` (string): Unique server identifier (8-12 characters)

### 3.2 Message Types

#### 3.2.1 Semantic Discovery Message (`t: "semantic_discover"`)
Advertises tool capabilities using natural language descriptions with structured connection information.

**Version 2.5 Update**: Added `connector` object with structured transport and authentication details.

```json
{
  "v": 2,
  "t": "semantic_discover", 
  "ts": 1727100286,
  "sid": "abc123def456",
  "tool": <tool_name>,
  "does": <capability_description>,
  "when": [<trigger_contexts>],
  "good_at": [<specific_strengths>],
  "bad_at": [<known_limitations>], 
  "connector": {
    "transport": <transport_type>,
    "endpoint": <connection_url>,
    "auth": <auth_requirements>,
    "protocol": <protocol_details>
  },
  "proven_by": {"uses": <count>, "success_rate": <float>}
}
```

##### Field Specifications:
- `tool` (string, required): Tool identifier, max 32 chars
- `does` (string, required): Natural language capability description, max 128 chars
- `when` (array, required): Trigger contexts, max 5 items, max 64 chars each
- `good_at` (array, optional): Specific strengths, max 5 items, max 32 chars each  
- `bad_at` (array, optional): Known limitations, max 3 items, max 32 chars each
- `connector` (object, required): Connection specification (v2.5)
- `proven_by` (object, optional): Usage statistics

##### Connector Object Specification:
```json
"connector": {
  "transport": "stdio" | "sse" | "http",
  "endpoint": "<url_or_command>",
  "auth": {
    "type": "none" | "bearer" | "x402" | "api_key",
    "required": <boolean>,
    "details": <auth_specific_object>
  },
  "protocol": {
    "type": "mcp" | "rest" | "grpc",
    "version": "<version_string>",
    "methods": [<available_methods>]
  }
}
```

**Connector Field Details:**
- `transport` (string, required): MCP connection transport type
  - `"stdio"`: Standard I/O (local command-line executable)
  - `"sse"`: HTTP Server-Sent Events (legacy MCP transport)
  - `"http"`: HTTP Streaming (modern MCP standard)
  
- `endpoint` (string, required): Connection URL or command
  - For `stdio`: Command to execute (e.g., `"npx @modelcontextprotocol/server-filesystem"`)
  - For `sse`: Full HTTP/HTTPS URL with SSE endpoint (e.g., `"https://api.example.com/sse"`)
  - For `http`: Full HTTP/HTTPS URL with MCP endpoint (e.g., `"https://api.example.com/mcp"`)
  
- `auth` (object, required): Authentication requirements
  - `type` (string, required): Authentication type
    - `"none"`: No authentication required
    - `"bearer"`: Bearer token in Authorization header
    - `"x402"`: x402 micropayment protocol
    - `"api_key"`: API key authentication
  - `required` (boolean, required): Whether authentication is mandatory
  - `details` (object, optional): Auth-specific configuration
    - For `x402`: `{"network": "base-sepolia", "asset": "0x036CbD...", "price_per_call": 1000000}`
    - For `bearer`: `{"header_name": "Authorization", "docs_url": "https://..."}`
    - For `api_key`: `{"param_name": "api_key", "location": "query" | "header"}`
    
- `protocol` (object, required): Protocol specification
  - `type` (string, required): Protocol type (`"mcp"`, `"rest"`, `"grpc"`)
  - `version` (string, required): Protocol version (e.g., `"2024-11-05"` for MCP)
  - `methods` (array, optional): Available methods/tools for validation

##### Example: HTTP Streaming MCP Server with x402 Payment
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1759843829,
  "sid": "robonet-mcp",
  "tool": "get_strategy_code",
  "does": "Retrieves algorithmic trading strategy source code and configuration",
  "when": ["need trading strategy", "backtest algorithm", "review strategy code"],
  "good_at": ["fast retrieval", "validated strategies", "multiple timeframes"],
  "bad_at": ["real-time execution", "strategy optimization"],
  "connector": {
    "transport": "http",
    "endpoint": "https://robonet.example.com:8080/mcp",
    "auth": {
      "type": "x402",
      "required": true,
      "details": {
        "network": "base-sepolia",
        "asset": "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
        "price_per_call": 1000000,
        "currency": "USDC"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call", "resources/list"]
    }
  },
  "proven_by": {
    "uses": 1523,
    "success_rate": 0.97
  }
}
```

##### Example: Local stdio MCP Server (No Auth)
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1759843829,
  "sid": "filesystem-local",
  "tool": "read_file",
  "does": "Reads file contents from local filesystem with encoding detection",
  "when": ["need file contents", "read configuration", "analyze source code"],
  "good_at": ["large files", "multiple encodings", "streaming"],
  "bad_at": ["remote files", "binary files"],
  "connector": {
    "transport": "stdio",
    "endpoint": "npx @modelcontextprotocol/server-filesystem /workspace",
    "auth": {
      "type": "none",
      "required": false
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    }
  },
  "proven_by": {
    "uses": 8472,
    "success_rate": 0.99
  }
}
```

##### Example: SSE MCP Server (Legacy Transport)
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1759843829,
  "sid": "legacy-mcp",
  "tool": "analyze_code",
  "does": "Analyzes code quality and suggests improvements",
  "when": ["code review", "check code quality", "find bugs"],
  "good_at": ["static analysis", "security checks", "style enforcement"],
  "bad_at": ["runtime debugging", "performance profiling"],
  "connector": {
    "transport": "sse",
    "endpoint": "https://legacy-mcp.example.com/sse",
    "auth": {
      "type": "bearer",
      "required": true,
      "details": {
        "header_name": "Authorization",
        "docs_url": "https://docs.legacy-mcp.example.com/auth"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2023-09-15",
      "methods": ["tools/list", "tools/call"]
    }
  },
  "proven_by": {
    "uses": 342,
    "success_rate": 0.95
  }
}
```

#### 3.2.2 Performance Update Message (`t: "perf_update"`)
Reports execution performance metrics, cost data, and optional invocation context.

**Version 2.1 Update**: Enhanced with optional execution context including sanitized arguments.

**Version 2.2 Update**: Added cost tracking for economic efficiency optimization.

```json
{
  "v": 2,
  "t": "perf_update",
  "ts": 1727100286, 
  "sid": "abc123def456",
  "tool": <tool_name>,
  "exec_ms": <execution_time>,
  "success": <boolean>,
  "cost_paid": <number>,
  "currency": <string>,
  "ctx": <context_object>
}
```

##### Field Specifications:
- `tool` (string, required): Tool identifier
- `exec_ms` (number, required): Execution time in milliseconds
- `success` (boolean, required): Whether execution succeeded
- `cost_paid` (number, optional): Actual cost charged in smallest currency units (v2.2)
- `currency` (string, optional): Currency identifier (e.g., "USDC", "ETH") (v2.2)
- `ctx` (object, optional): Execution context, MAY include:
  - `args` (object, optional): Sanitized input parameters (see 6.3.1)
  - `result_size` (number, optional): Response size in bytes
  - `cache_hit` (boolean, optional): Cache status
  - `error_code` (string, optional): Error identifier if `success: false`
  - Additional implementation-specific fields

##### Example with Cost Tracking (v2.2):
```json
{
  "v": 2,
  "t": "perf_update",
  "ts": 1759843829,
  "sid": "workbench-mcp",
  "tool": "get_strategy_code",
  "exec_ms": 450,
  "success": true,
  "cost_paid": 1000000,
  "currency": "USDC",
  "ctx": {
    "args": {
      "strategy_name": "AIEnhancedPattern..."
    },
    "result_size": 15420,
    "cache_hit": false
  }
}
```

**Note on cost_paid**: Value is in smallest currency units (e.g., 1000000 = 0.001 USDC with 6 decimals). Implementations should document their currency's decimal precision.

#### 3.2.3 Error Pattern Message (`t: "error_pattern"`)  
Describes failure modes and mitigation strategies.

```json
{
  "v": 2,
  "t": "error_pattern",
  "ts": 1727100286,
  "sid": "abc123def456", 
  "tool": <tool_name>,
  "error": <error_type>,
  "trigger": <failure_conditions>,
  "solution": <recommended_action>
}
```

## 4. Transport Protocol Requirements

### 4.1 UDP Advertisement Protocol
- **Port**: 10191
- **Packet Size**: MUST NOT exceed 1472 bytes (avoid fragmentation)
- **Encoding**: UTF-8 JSON
- **Reliability**: Best effort delivery (fire-and-forget)
- **Size Management**: If message with `connector` exceeds 1400 bytes, implementations SHOULD:
  - Omit optional `connector.protocol.methods` array
  - Truncate `auth.details.docs_url` or similar long fields
  - Prioritize: `tool` → `connector.transport` → `connector.endpoint` → `connector.auth.type` → other fields

### 4.2 WebSocket Distribution Protocol  
- **Upgrade Protocol**: HTTP/1.1 WebSocket upgrade
- **Subprotocol**: `dcap-v2`
- **Message Format**: JSON text frames
- **Heartbeat**: PING/PONG every 30 seconds

## 5. Discovery Algorithm

### 5.1 Agent Discovery Process
```
1. Agent receives task request
2. Parse semantic intent from request
3. Query accumulated tool knowledge base
4. Match intent against tool descriptions using:
   a. Direct keyword matching in 'when' array
   b. Semantic similarity scoring on 'does' field  
   c. Capability intersection with 'good_at' array
5. Rank candidates by:
   a. proven_by.success_rate (reliability)
   b. Average exec_ms (speed) (v2.1)
   c. Average cost_paid (economic efficiency) (v2.2)
6. Extract connector details from selected tool (v2.5):
   a. Parse transport type and endpoint
   b. Prepare authentication credentials
   c. Establish connection according to protocol type
7. Execute task with acquired capability
```

### 5.2 Semantic Matching Requirements
Implementations SHOULD support:
- Exact string matching for triggers
- Fuzzy string matching (edit distance < 3)
- Semantic similarity scoring (cosine similarity > 0.7)

### 5.3 Chain Pattern Detection (v2.1)
Intelligence consumers MAY track sequences of `perf_update` messages to identify tool usage patterns:
- Group messages by `sid` (server identifier)
- Track temporal proximity (typically 5-minute window)
- Build statistical models of successful tool sequences
- Use patterns to recommend optimized workflows

### 5.4 Economic Efficiency Optimization (v2.2)
When `cost_paid` and `currency` are present, intelligence consumers SHOULD:
- Track total cost alongside execution time
- Calculate efficiency score: `success_rate / (exec_ms + normalized_cost)`
- Identify cost-effective alternatives for equivalent capabilities
- Optimize tool chains for both speed and cost

### 5.5 Dynamic Tool Acquisition (v2.5)
Agents implementing dynamic acquisition MUST:
1. **Validate Connector**: Verify transport type is supported
2. **Prepare Authentication**: Obtain required credentials based on `auth.type`
   - For `x402`: Initialize payment stream with specified network/asset
   - For `bearer`: Retrieve token from secure storage
   - For `api_key`: Load key from environment or credential manager
3. **Establish Connection**: Based on transport type:
   - `stdio`: Spawn child process with specified command
   - `sse`: Open HTTP connection, establish SSE stream (legacy MCP transport)
   - `http`: Open HTTP connection, use streaming HTTP (modern MCP transport)
4. **Verify Protocol**: Confirm protocol type and version compatibility
5. **Invoke Tool**: Execute tool call according to protocol specification
6. **Handle Errors**: Implement retry logic and fallback to alternative tools

## 6. Security Considerations

### 6.1 Denial of Service Protection
- Rate limiting: Max 100 messages per source IP per minute
- Message size validation: Reject packets > 1472 bytes
- Malformed message filtering: Strict JSON schema validation

### 6.2 Capability Validation
- Agents MUST validate tool endpoints before connection
- Sandbox unknown tools during initial execution
- Monitor tool behavior for anomalies
- Verify TLS certificates for `https://` endpoints (v2.5)
- For `stdio` transport, validate commands are from trusted sources

### 6.3 Privacy Considerations
- Server identifiers SHOULD be pseudonymous
- No personally identifiable information in broadcasts
- Tool usage patterns may reveal sensitive information
- Cost data is semi-public by nature (on-chain transactions)

#### 6.3.1 Argument Sanitization (v2.1)
When including `ctx.args` in `perf_update` messages, implementations MUST:
- **Truncate** string values exceeding 32 characters (append "...")
- **Hash** or **omit** values containing:
  - API keys, tokens, or credentials
  - Personally identifiable information (PII)
  - Sensitive business data
  - File paths revealing system structure
- **Consider** omitting `ctx.args` entirely if sanitization is complex

##### Example Sanitization:
```javascript
// Original args
{
  "api_key": "sk_live_abc123...",
  "user_email": "user@example.com",
  "query": "What are the top performing strategies?"
}

// Sanitized for broadcast
{
  "api_key": "[REDACTED]",
  "user_email": "[REDACTED]", 
  "query": "What are the top performin..."
}
```

#### 6.3.2 Cost Data Transparency (v2.2)
Cost information in `perf_update` messages:
- Reflects actual charged amount, not internal pricing structure
- Is already observable through blockchain/payment protocol
- Enables market efficiency through price transparency
- Tools MAY omit cost data if business model requires confidentiality

#### 6.3.3 Endpoint Security (v2.5)
When broadcasting `connector` information:
- **Public Endpoints**: Include full connection details
- **Private Endpoints**: Use access-controlled relay or omit from public broadcasts
- **Authentication**: NEVER include actual credentials (keys, tokens) in broadcasts
  - Only specify the `auth.type` and where to obtain credentials
- **TLS Required**: All public HTTP endpoints SHOULD use `https://` URLs
- **Command Injection**: For `stdio` transport, validate command strings are from trusted sources and not user-controlled

## 7. Implementation Guidelines  

### 7.1 Tool Provider Requirements
Tools implementing DCAP MUST:
- Generate unique, stable server identifiers
- Broadcast `semantic_discover` on first capability use with complete `connector` details (v2.5)
- Send `perf_update` messages for significant events
- Respect UDP packet size limits
- Sanitize arguments before including in `ctx.args` (v2.1)
- Report actual cost charged in `cost_paid` when applicable (v2.2)
- Ensure `connector.endpoint` is reachable from agent networks (v2.5)
- Keep authentication requirements current in `connector.auth` (v2.5)

### 7.2 Agent Consumer Requirements  
Agents implementing DCAP MUST:
- Maintain local capability knowledge base
- Handle UDP packet loss gracefully
- Implement connection retry logic for tool acquisition
- Validate tool responses before use
- Respect privacy of observed `ctx.args` data (v2.1)
- Consider cost alongside performance when selecting tools (v2.2)
- Parse and validate `connector` information before attempting connection (v2.5)
- Implement secure credential storage for auth tokens (v2.5)
- Support multiple transport types or gracefully skip unsupported tools (v2.5)

### 7.3 Hub Implementation Requirements
Intelligence hubs MUST:
- Accept UDP packets on port 10191  
- Relay messages via WebSocket without modification
- Support multiple concurrent WebSocket connections
- Implement basic DoS protection

### 7.4 Intelligence Consumer Requirements (v2.1, updated v2.2, v2.5)
Systems consuming DCAP streams for intelligence (e.g., Oracle agents) SHOULD:
- Track `perf_update` sequences by `sid` for pattern detection
- Maintain statistical models of tool performance AND cost (v2.2)
- Respect privacy constraints when analyzing `ctx.args`
- Only recommend patterns that were ACTUALLY OBSERVED
- Calculate efficiency metrics incorporating both time and cost (v2.2)
- Index tools by `connector.transport` for transport-specific recommendations (v2.5)
- Track authentication requirements to inform agents of payment/access needs (v2.5)

## 8. References

### 8.1 Normative References
- [RFC2119] Key words for use in RFCs
- [RFC6455] The WebSocket Protocol  
- [RFC768] User Datagram Protocol
- [MCP] Model Context Protocol Specification

### 8.2 Informative References
- [AutoGPT] Autonomous GPT-4 Experiment
- [LangChain] Framework for developing applications with LLMs
- [x402] x402 Micropayment Protocol

## 9. Changelog

### Version 2.5 (October 2025)
**Added:**
- `connector` object to `semantic_discover` message with structured connection details
- `transport` field specifying connection type (websocket, stdio, http, https)
- `endpoint` field with full connection URL or command
- `auth` object with authentication type and requirements
- `protocol` object specifying protocol type, version, and methods
- Section 5.5: Dynamic tool acquisition guidelines
- Section 6.2: TLS certificate validation requirement
- Section 6.3.3: Endpoint security considerations
- Updated implementation requirements for v2.5 features

**Removed:**
- Deprecated `connects_to` field (replaced by structured `connector` object)

**Rationale:**
- Enables fully autonomous tool acquisition without manual configuration
- Agents can programmatically connect to any discovered tool
- Structured authentication details enable automated credential management
- Transport specification allows agents to support multiple connection types
- Critical step toward true dynamic capability acquisition

**Migration from v2.2:**
- `connects_to` field replaced by `connector.endpoint`
- Backward compatibility: Consumers can fall back to treating `connects_to` as simple endpoint
- New implementations MUST use `connector` object
- Existing v2.2 implementations continue to work but miss dynamic acquisition benefits

### Version 2.2 (October 2025)
**Added:**
- `cost_paid` field to `perf_update` message for economic tracking
- `currency` field to `perf_update` message for multi-currency support
- Section 5.4: Economic efficiency optimization guidelines
- Section 6.3.2: Cost data transparency considerations
- Updated Section 5.1: Ranking now includes cost optimization

**Rationale:**
- Performance includes both speed and cost
- Oracle agents need cost data to recommend economically efficient tool chains
- Transparency enables market efficiency and price discovery
- Cost is already semi-public through payment protocols (e.g., x402, blockchain)
- Maintains backward compatibility (cost fields optional)

### Version 2.1 (October 2025)
**Added:**
- Enhanced `perf_update` message with optional `ctx` object
- Support for sanitized `ctx.args` in performance updates
- Section 5.3: Chain pattern detection guidelines
- Section 6.3.1: Argument sanitization requirements
- Section 7.4: Intelligence consumer requirements

**Rationale:**
- Enables pattern detection and chain optimization without introducing new message types
- Maintains backward compatibility (all new fields optional)
- Addresses privacy concerns through explicit sanitization requirements

### Version 2.0 (September 2025)
- Initial public specification

## Appendix A. Example Dynamic Acquisition Implementation

```javascript
// Dynamic Tool Acquisition Client (v2.5)
class DynamicDCAPAgent {
  constructor() {
    this.knownTools = new Map();
    this.ws = new WebSocket('ws://hub:10191', 'dcap-v2');
    this.ws.onmessage = this.handleMessage.bind(this);
  }
  
  handleMessage(event) {
    const msg = JSON.parse(event.data);
    if (msg.t === 'semantic_discover') {
      this.knownTools.set(msg.tool, msg);
    }
  }
  
  async acquireAndInvokeTool(capability, args) {
    // 1. Find matching tool
    const tool = this.findBestTool(capability);
    if (!tool) throw new Error('No tool found for capability');
    
    // 2. Extract connector details
    const { transport, endpoint, auth, protocol } = tool.connector;
    
    // 3. Prepare authentication
    const credentials = await this.prepareAuth(auth);
    
    // 4. Establish connection based on transport
    let client;
    switch (transport) {
      case 'stdio':
        client = await this.spawnStdio(endpoint, protocol);
        break;
      case 'sse':
        client = await this.connectSSE(endpoint, credentials, protocol);
        break;
      case 'http':
        client = await this.connectHTTPStreaming(endpoint, credentials, protocol);
        break;
      default:
        throw new Error(`Unsupported transport: ${transport}`);
    }
    
    // 5. Invoke tool
    const result = await client.callTool(tool.tool, args);
    
    // 6. Clean up
    await client.disconnect();
    
    return result;
  }
  
  async prepareAuth(authConfig) {
    switch (authConfig.type) {
      case 'none':
        return null;
        
      case 'bearer':
        // Retrieve from secure storage or prompt user
        return { token: await this.getBearerToken() };
        
      case 'x402':
        // Initialize payment stream
        const { network, asset, price_per_call } = authConfig.details;
        return await this.initializeX402Payment(network, asset, price_per_call);
        
      case 'api_key':
        return { api_key: await this.getApiKey() };
        
      default:
        throw new Error(`Unsupported auth type: ${authConfig.type}`);
    }
  }
  
  async connectSSE(endpoint, credentials, protocol) {
    // SSE (Server-Sent Events) - Legacy MCP transport
    const EventSource = require('eventsource');
    
    const headers = {};
    if (credentials?.token) {
      headers['Authorization'] = `Bearer ${credentials.token}`;
    }
    if (credentials?.x402) {
      headers['X-Payment'] = credentials.x402.paymentHeader;
    }
    
    const es = new EventSource(endpoint, { headers });
    
    return {
      callTool: async (toolName, args) => {
        // SSE uses GET for receiving, POST for sending
        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...headers
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            method: 'tools/call',
            params: { name: toolName, arguments: args },
            id: Date.now()
          })
        });
        
        return await response.json();
      },
      disconnect: async () => {
        es.close();
      }
    };
  }
  
  async connectHTTPStreaming(endpoint, credentials, protocol) {
    // HTTP Streaming - Modern MCP transport
    const headers = {
      'Content-Type': 'application/json',
      'Accept': 'text/event-stream'
    };
    
    if (credentials?.token) {
      headers['Authorization'] = `Bearer ${credentials.token}`;
    }
    if (credentials?.x402) {
      headers['X-Payment'] = credentials.x402.paymentHeader;
    }
    
    // Perform MCP initialization
    await this.sendMCPInitializeHTTP(endpoint, headers, protocol.version);
    
    return {
      callTool: async (toolName, args) => {
        const response = await fetch(endpoint, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            jsonrpc: '2.0',
            method: 'tools/call',
            params: { name: toolName, arguments: args },
            id: Date.now()
          })
        });
        
        const result = await response.json();
        return result.error ? Promise.reject(result.error) : result.result;
      },
      disconnect: async () => {
        // HTTP is stateless, no cleanup needed
      }
    };
  }
  
  async spawnStdio(command, protocol) {
    const { spawn } = require('child_process');
    const proc = spawn(command, { shell: true, stdio: ['pipe', 'pipe', 'inherit'] });
    
    // Perform MCP initialization
    await this.sendMCPInitialize(proc.stdin, protocol.version);
    
    return {
      callTool: async (toolName, args) => {
        const request = {
          jsonrpc: '2.0',
          method: 'tools/call',
          params: { name: toolName, arguments: args },
          id: Date.now()
        };
        
        proc.stdin.write(JSON.stringify(request) + '\n');
        
        // Read response
        return new Promise((resolve, reject) => {
          const handler = (data) => {
            const response = JSON.parse(data.toString());
            if (response.id === request.id) {
              proc.stdout.removeListener('data', handler);
              response.error ? reject(response.error) : resolve(response.result);
            }
          };
          proc.stdout.on('data', handler);
        });
      },
      disconnect: async () => {
        proc.kill();
      }
    };
  }
  
  async sendMCPInitialize(stream, version) {
    // For stdio transport
    const init = {
      jsonrpc: '2.0',
      method: 'initialize',
      params: {
        protocolVersion: version,
        clientInfo: { name: 'dynamic-dcap-agent', version: '2.5.0' }
      },
      id: 1
    };
    
    stream.write(JSON.stringify(init) + '\n');
    
    // Wait for initialize response (simplified)
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  async sendMCPInitializeHTTP(endpoint, headers, version) {
    // For HTTP transport
    const init = {
      jsonrpc: '2.0',
      method: 'initialize',
      params: {
        protocolVersion: version,
        clientInfo: { name: 'dynamic-dcap-agent', version: '2.5.0' }
      },
      id: 1
    };
    
    await fetch(endpoint, {
      method: 'POST',
      headers,
      body: JSON.stringify(init)
    });
    
    // Wait for initialization to complete (simplified)
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  async initializeX402Payment(network, asset, pricePerCall) {
    // Use x402 library to create payment stream
    const { createPayment } = require('x402');
    
    const payment = await createPayment({
      network,
      asset,
      amount: pricePerCall * 10, // Pre-pay for 10 calls
      recipient: '0x...' // Tool provider address
    });
    
    return {
      x402: {
        paymentHeader: JSON.stringify(payment)
      }
    };
  }
  
  findBestTool(capability) {
    // Semantic matching (simplified)
    for (const tool of this.knownTools.values()) {
      if (tool.when.some(trigger => 
        capability.toLowerCase().includes(trigger.toLowerCase())
      )) {
        return tool;
      }
    }
    return null;
  }
}

// Usage Example
const agent = new DynamicDCAPAgent();

// Wait for discovery
await new Promise(resolve => setTimeout(resolve, 5000));

// Dynamically acquire and invoke tool
const strategyCode = await agent.acquireAndInvokeTool(
  'get trading strategy code',
  { strategy_name: 'AIEnhancedPatternRecognition_BTC' }
);

console.log('Retrieved strategy:', strategyCode);
```

## Authors' Addresses

Martin Maurer  
Email: empeamtk@googlemail.com

