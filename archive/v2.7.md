# Dynamic Capability Acquisition Protocol (DCAP)

**Version**: 2.7  
**Date**: November 2025  
**Author**: M. Maurer  

## Abstract

This document defines the Dynamic Capability Acquisition Protocol (DCAP), a decentralized protocol enabling autonomous agents to discover, evaluate, and acquire computational capabilities at runtime through semantic broadcasting. DCAP uses UDP multicast for capability advertisement and WebSocket streams for real-time intelligence distribution. Version 2.7 introduces optional blockchain registration metadata, enabling integration with ERC-8004 and other on-chain trust layers.


## 1. Introduction

### 1.1 Problem Statement
Current autonomous agent systems operate with fixed, pre-configured tool sets, limiting their ability to handle novel or specialized tasks. Existing tool discovery mechanisms rely on centralized registries, creating bottlenecks and single points of failure. Additionally, discovered tools often lack sufficient connection metadata, making autonomous acquisition impractical. For high-value scenarios requiring trust guarantees, blockchain-based registries like ERC-8004 provide identity and reputation but lack real-time discovery and connection automation.

### 1.2 Solution Overview
DCAP enables tools to self-advertise their capabilities using semantic descriptions, allowing agents to discover and dynamically load appropriate tools based on task requirements rather than static configuration. Version 2.7 introduces optional blockchain registration metadata, positioning DCAP as the off-chain discovery and performance layer that complements on-chain trust systems like ERC-8004.

**Two-Layer Architecture:**
- **DCAP (Off-Chain)**: Fast discovery, connection automation, performance telemetry, zero cost
- **ERC-8004 (On-Chain)**: Immutable identity, reputation aggregation, cryptographic validation, audit trail

Together, they enable complete agent economies: fast discovery with blockchain trust anchoring.

## 2. Protocol Architecture

### 2.1 Network Topology
```
Tool Provider → UDP Broadcast → Intelligence Hub → WebSocket → Agent Consumer
     ^                              ^                   ^           ^
   MCP Tool                   Stream Aggregator    Real-time     Dynamic Agent
                                                                      ↓
                                                            Dynamic Tool Invocation
                                                                      ↓
                                                          Optional: ERC-8004 Verification
```

### 2.2 Transport Layers
- **Advertisement Layer**: UDP packets (port 10191)
- **Distribution Layer**: WebSocket streams 
- **Acquisition Layer**: MCP protocol over stdio/HTTP/SSE (specified in connector)
- **Trust Layer**: Blockchain verification (optional, via ERC-8004 or similar)

### 2.3 Two-Tier Trust Model (v2.7)
DCAP operates as the fast discovery layer, with optional blockchain anchoring:

```
┌─────────────────────────────────────────────────────┐
│  ERC-8004 (On-Chain Trust Layer)                   │
│  ✓ Permanent identity (ERC-721)                    │
│  ✓ Reputation aggregation                           │
│  ✓ Cryptographic validation                         │
│  ✓ Audit trail                                      │
│  ✗ Real-time discovery                             │
│  ✗ Performance metrics                             │
│  ✗ Connection details                               │
└─────────────────────────────────────────────────────┘
                       ↕
        blockchain anchoring / verification
                       ↕
┌─────────────────────────────────────────────────────┐
│  DCAP (Off-Chain Discovery Layer)                  │
│  ✓ Real-time broadcasts (milliseconds)             │
│  ✓ Detailed connection specs (OAuth2, headers...) │
│  ✓ Performance telemetry (exec_ms, cost_paid)      │
│  ✓ Pattern detection (tool chains)                 │
│  ✓ Zero registration cost                          │
│  ✓ Private network support                         │
│  ✗ Immutable audit trail                           │
│  ✗ Cross-org legal guarantees                      │
└─────────────────────────────────────────────────────┘
```

**Why This Architecture:**
- Blockchain is too slow/expensive for real-time discovery
- DCAP provides what ERC-8004 lacks: connection automation, performance data
- ERC-8004 provides what DCAP lacks: immutable trust guarantees
- Together: fast discovery with blockchain trust anchoring

## 3. Message Format Specification

### 3.1 Base Message Structure
All DCAP messages MUST conform to this JSON schema:

```json
{
  "v": <protocol_version>,
  "t": <message_type>, 
  "ts": <unix_timestamp>,
  "sid": <server_identifier>,
  [message_specific_fields]
}
```

#### Required Fields:
- `v` (number): Protocol version (current: 2)
- `t` (string): Message type identifier
- `ts` (number): Unix timestamp of message creation
- `sid` (string): Unique server identifier (8-12 characters)

### 3.2 Message Types

#### 3.2.1 Semantic Discovery Message (`t: "semantic_discover"`)
Advertises tool capabilities using natural language descriptions with comprehensive connection information and optional blockchain registration.

**Version 2.7 Update**: Added optional `blockchain_registrations` array for ERC-8004 and other blockchain trust anchoring.

```json
{
  "v": 2,
  "t": "semantic_discover", 
  "ts": 1727100286,
  "sid": "abc123def456",
  "tool": <tool_name>,
  "does": <capability_description>,
  "when": [<trigger_contexts>],
  "good_at": [<specific_strengths>],
  "bad_at": [<known_limitations>], 
  "connector": {
    "transport": <transport_type>,
    "endpoint": <connection_url>,
    "auth": <auth_requirements>,
    "headers": <required_headers>,
    "protocol": <protocol_details>,
    "session": <session_requirements>
  },
  "blockchain_registrations": [<blockchain_registration>],
  "proven_by": {"uses": <count>, "success_rate": <float>}
}
```

##### Field Specifications:
- `tool` (string, required): Tool identifier, max 32 chars
- `does` (string, required): Natural language capability description, max 128 chars
- `when` (array, required): Trigger contexts, max 5 items, max 64 chars each
- `good_at` (array, optional): Specific strengths, max 5 items, max 32 chars each  
- `bad_at` (array, optional): Known limitations, max 3 items, max 32 chars each
- `connector` (object, required): Connection specification (enhanced v2.6)
- `blockchain_registrations` (array, optional): Blockchain trust registrations (v2.7)
- `proven_by` (object, optional): Usage statistics

##### Blockchain Registration Object Specification (v2.7):
```json
"blockchain_registrations": [
  {
    "protocol": "erc-8004" | "erc-721" | "<other_standard>",
    "namespace": "eip155",
    "chain_id": <number>,
    "registry": "<contract_address>",
    "agent_id": <number_or_string>,
    "verification_url": "<explorer_url>",
    "metadata_uri": "<ipfs_or_http_uri>"
  }
]
```

**Blockchain Registration Field Details:**
- `protocol` (string, required): Blockchain standard identifier
  - `"erc-8004"`: ERC-8004 Agent Registry standard
  - `"erc-721"`: Generic NFT-based identity
  - Other standards as they emerge
- `namespace` (string, required): Chain namespace identifier (e.g., `"eip155"` for EVM chains)
- `chain_id` (number, required): Chain identifier (e.g., `1` for Ethereum mainnet, `8453` for Base)
- `registry` (string, required): Contract address of the registry
- `agent_id` (number or string, required): Agent identifier within the registry (typically NFT token ID)
- `verification_url` (string, optional): Human-readable verification link (e.g., Etherscan NFT page)
- `metadata_uri` (string, optional): URI to registration metadata (IPFS, HTTP, etc.)

**Note**: Tools MAY include multiple blockchain registrations (e.g., registered on multiple chains or standards). Agents SHOULD verify registrations when handling high-value scenarios.

##### Connector Object Specification (v2.6):
```json
"connector": {
  "transport": "stdio" | "sse" | "http",
  "endpoint": "<url_or_command>",
  "auth": {
    "type": "none" | "oauth2" | "bearer" | "x402" | "api_key",
    "required": <boolean>,
    "details": <auth_specific_object>
  },
  "headers": {
    "required": [<header_name>],
    "optional": {<header_name>: <default_value>}
  },
  "protocol": {
    "type": "mcp" | "rest" | "grpc",
    "version": "<version_string>",
    "methods": [<available_methods>]
  },
  "session": {
    "required": <boolean>,
    "initialization": <init_details>
  }
}
```

(Full connector specification details from v2.6 remain unchanged - see v2.6.md for complete details)

##### Example: Financial Tool with ERC-8004 Registration (v2.7)
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1735000000,
  "sid": "finadv-mcp",
  "tool": "financial_advisor",
  "does": "Provides SEC-compliant investment advice with malpractice insurance",
  "when": ["investment advice", "portfolio analysis", "financial planning"],
  "good_at": ["SEC compliance", "risk assessment", "tax optimization"],
  "bad_at": ["real-time trading", "crypto speculation"],
  "connector": {
    "transport": "http",
    "endpoint": "https://finadvice.ai/mcp",
    "auth": {
      "type": "oauth2",
      "required": true,
      "details": {
        "flow": "authorization_code",
        "auth_url": "https://finadvice.ai/oauth/authorize",
        "token_url": "https://finadvice.ai/oauth/token",
        "scopes": ["financial:read", "financial:advise"],
        "instructions_url": "https://finadvice.ai/docs/authentication",
        "pkce_required": true
      }
    },
    "headers": {
      "required": ["Accept", "Content-Type"],
      "optional": {
        "Accept": "application/json",
        "Content-Type": "application/json"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    },
    "session": {
      "required": false
    }
  },
  "blockchain_registrations": [
    {
      "protocol": "erc-8004",
      "namespace": "eip155",
      "chain_id": 1,
      "registry": "0x1234567890123456789012345678901234567890",
      "agent_id": 42,
      "verification_url": "https://etherscan.io/nft/0x1234...7890/42",
      "metadata_uri": "ipfs://QmXyZ..."
    }
  ],
  "proven_by": {
    "uses": 5420,
    "success_rate": 0.98
  }
}
```

##### Example: Healthcare Tool with ERC-8004 Registration (v2.7)
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1735000000,
  "sid": "meddiag-mcp",
  "tool": "medical_diagnosis",
  "does": "AI-powered medical diagnosis with malpractice insurance coverage",
  "when": ["medical diagnosis", "symptom analysis", "treatment recommendation"],
  "good_at": ["pattern recognition", "rare disease detection", "evidence-based"],
  "bad_at": ["physical examination", "surgical procedures"],
  "connector": {
    "transport": "http",
    "endpoint": "https://meddiag.ai/mcp",
    "auth": {
      "type": "api_key",
      "required": true,
      "details": {
        "location": "header",
        "param_name": "X-API-Key",
        "format": "{key}",
        "instructions_url": "https://meddiag.ai/docs/api-keys",
        "credential_source": "env:MEDDIAG_API_KEY",
        "registration_url": "https://meddiag.ai/signup"
      }
    },
    "headers": {
      "required": ["Accept", "X-API-Key"],
      "optional": {
        "Accept": "application/json"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    },
    "session": {
      "required": false
    }
  },
  "blockchain_registrations": [
    {
      "protocol": "erc-8004",
      "namespace": "eip155",
      "chain_id": 8453,
      "registry": "0xabcdefabcdefabcdefabcdefabcdefabcdefabcd",
      "agent_id": 123,
      "verification_url": "https://basescan.org/nft/0xabcd...efab/123",
      "metadata_uri": "ipfs://QmAaBb..."
    }
  ],
  "proven_by": {
    "uses": 8234,
    "success_rate": 0.96
  }
}
```

##### Example: Local Tool Without Blockchain Registration (v2.7)
```json
{
  "v": 2,
  "t": "semantic_discover",
  "ts": 1735000000,
  "sid": "filesystem-local",
  "tool": "read_file",
  "does": "Reads file contents from local filesystem",
  "when": ["need file contents", "read configuration"],
  "good_at": ["large files", "multiple encodings"],
  "bad_at": ["remote files", "binary files"],
  "connector": {
    "transport": "stdio",
    "endpoint": "npx @modelcontextprotocol/server-filesystem /workspace",
    "auth": {
      "type": "none",
      "required": false,
      "details": {
        "notes": "Local filesystem access, no authentication needed"
      }
    },
    "protocol": {
      "type": "mcp",
      "version": "2024-11-05",
      "methods": ["tools/list", "tools/call"]
    },
    "session": {
      "required": false
    }
  },
  "proven_by": {
    "uses": 8472,
    "success_rate": 0.99
  }
}
```

**Note**: `blockchain_registrations` is optional. Tools without blockchain registration still function fully via DCAP. Blockchain registration is recommended for high-value scenarios (financial, healthcare, legal) but not required for development tools or local services.

#### 3.2.2 Performance Update Message (`t: "perf_update"`)
(Unchanged from v2.6 - see v2.6.md for complete specification)

#### 3.2.3 Error Pattern Message (`t: "error_pattern"`)  
(Unchanged from v2.6 - see v2.6.md for complete specification)

## 4. Transport Protocol Requirements

### 4.1 UDP Advertisement Protocol
- **Port**: 10191
- **Packet Size**: MUST NOT exceed 1472 bytes (avoid fragmentation)
- **Encoding**: UTF-8 JSON
- **Reliability**: Best effort delivery (fire-and-forget)
- **Size Management** (v2.7 updated): If message with `blockchain_registrations` exceeds 1400 bytes, implementations SHOULD truncate in this priority order:
  1. Omit `blockchain_registrations` array (v2.7)
  2. Omit `connector.session` object
  3. Omit `connector.headers.optional` object
  4. Omit `connector.protocol.methods` array
  5. Truncate `auth.details.instructions_url` to domain only
  6. Omit `auth.details.registration_url`
  7. Keep: `tool`, `connector.transport`, `connector.endpoint`, `connector.auth.type`, `connector.auth.required`

**Note**: If `blockchain_registrations` is omitted due to size constraints, tools SHOULD broadcast a separate discovery message with only blockchain registration details, or provide verification via alternative channels (e.g., DNS TXT records, well-known endpoints).

### 4.2 WebSocket Distribution Protocol  
- **Upgrade Protocol**: HTTP/1.1 WebSocket upgrade
- **Subprotocol**: `dcap-v2`
- **Message Format**: JSON text frames
- **Heartbeat**: PING/PONG every 30 seconds

## 5. Discovery Algorithm

### 5.1 Agent Discovery Process
```
1. Agent receives task request
2. Parse semantic intent from request
3. Query accumulated tool knowledge base
4. Match intent against tool descriptions using:
   a. Direct keyword matching in 'when' array
   b. Semantic similarity scoring on 'does' field  
   c. Capability intersection with 'good_at' array
5. Rank candidates by:
   a. proven_by.success_rate (reliability)
   b. Average exec_ms (speed) (v2.1)
   c. Average cost_paid (economic efficiency) (v2.2)
   d. Auth complexity (prefer 'none' > 'api_key' > 'bearer' > 'oauth2') (v2.6)
   e. Blockchain registration presence (v2.7) - prefer registered for high-value scenarios
6. For high-value scenarios, verify blockchain registration (v2.7):
   a. Query on-chain registry for agent_id
   b. Verify reputation/validation status
   c. Check insurance/validation pool if applicable
   d. Fall back to DCAP-only if verification fails or unavailable
7. Extract connector details from selected tool (v2.5, enhanced v2.6):
   a. Parse transport type and endpoint
   b. Check authentication requirements and available credentials
   c. Verify required headers can be provided
   d. Prepare session initialization if needed
   e. Establish connection according to protocol type
8. Execute task with acquired capability
9. Post feedback to both DCAP (real-time) and blockchain (if registered) (v2.7)
```

### 5.2 Semantic Matching Requirements
Implementations SHOULD support:
- Exact string matching for triggers
- Fuzzy string matching (edit distance < 3)
- Semantic similarity scoring (cosine similarity > 0.7)

### 5.3 Chain Pattern Detection (v2.1)
(Unchanged from v2.6 - see v2.6.md)

### 5.4 Economic Efficiency Optimization (v2.2)
(Unchanged from v2.6 - see v2.6.md)

### 5.5 Dynamic Tool Acquisition (v2.5, enhanced v2.6)
(Unchanged from v2.6 - see v2.6.md)

### 5.6 Credential Management (v2.6)
(Unchanged from v2.6 - see v2.6.md)

### 5.7 Blockchain Verification (v2.7)
Agents implementing blockchain verification SHOULD:

1. **Check Registration Presence**: If `blockchain_registrations` array is present and non-empty
2. **Determine Verification Need**: 
   - High-value scenarios (financial, healthcare, legal): REQUIRED
   - Development tools, local services: OPTIONAL
3. **Query On-Chain Registry**:
   - Connect to blockchain via RPC (e.g., Infura, Alchemy, public node)
   - Query registry contract for agent_id
   - Retrieve reputation scores, validation status, insurance pool
4. **Verify Metadata**:
   - Fetch metadata from `metadata_uri` (IPFS, HTTP)
   - Verify metadata matches DCAP broadcast
   - Check expiration/revocation status
5. **Decision Logic**:
   - If verification passes: Proceed with tool invocation
   - If verification fails: Skip tool or warn user
   - If verification unavailable: Fall back to DCAP-only (statistical trust)
6. **Post-Feedback**:
   - Broadcast `perf_update` to DCAP (real-time)
   - Optionally submit feedback to blockchain registry (permanent record)

**Example Verification Flow:**
```javascript
async function verifyBlockchainRegistration(tool) {
  if (!tool.blockchain_registrations || tool.blockchain_registrations.length === 0) {
    return { verified: false, reason: 'no_registration' };
  }
  
  const registration = tool.blockchain_registrations[0];
  
  if (registration.protocol === 'erc-8004') {
    // Query ERC-8004 registry contract
    const registry = new ethers.Contract(
      registration.registry,
      ERC8004_ABI,
      provider
    );
    
    const agentData = await registry.getAgent(registration.agent_id);
    
    return {
      verified: agentData.isValid,
      reputation: agentData.averageScore,
      feedbackCount: agentData.feedbackCount,
      insurancePool: agentData.insurancePool,
      validationStatus: agentData.status
    };
  }
  
  return { verified: false, reason: 'unsupported_protocol' };
}
```

## 6. Security Considerations

### 6.1 Denial of Service Protection
(Unchanged from v2.6 - see v2.6.md)

### 6.2 Capability Validation
- Agents MUST validate tool endpoints before connection
- Sandbox unknown tools during initial execution
- Monitor tool behavior for anomalies
- Verify TLS certificates for `https://` endpoints (v2.5)
- For `stdio` transport, validate commands are from trusted sources
- Validate OAuth redirect URIs match `auth_url` domain (v2.6)
- Never execute stdio commands with user-controlled input
- **Verify blockchain registrations match on-chain data** (v2.7)
- **Validate metadata URIs are accessible and match broadcast** (v2.7)

### 6.3 Privacy Considerations
(Unchanged from v2.6 - see v2.6.md)

#### 6.3.1 Argument Sanitization (v2.1)
(Unchanged from v2.6 - see v2.6.md)

#### 6.3.2 Cost Data Transparency (v2.2)
(Unchanged from v2.6 - see v2.6.md)

#### 6.3.3 Endpoint Security (v2.5, updated v2.6)
(Unchanged from v2.6 - see v2.6.md)

#### 6.3.4 OAuth Security (v2.6)
(Unchanged from v2.6 - see v2.6.md)

#### 6.3.5 Blockchain Registration Security (v2.7)
When verifying blockchain registrations:
- **Registry Address Validation**: Verify registry contract address matches known ERC-8004 registry
- **Chain ID Verification**: Confirm chain_id matches expected network
- **Metadata Integrity**: Verify metadata_uri content matches DCAP broadcast claims
- **Revocation Checks**: Query registry for revocation/expiration status
- **Replay Protection**: Verify registration timestamps are recent (not stale)
- **Multi-Registration**: If multiple registrations present, verify all are valid (don't trust single valid registration if others are invalid)

**Warning**: Blockchain registration does NOT guarantee tool safety. It provides identity and reputation anchoring, but agents must still validate tool behavior and implement sandboxing.

## 7. Implementation Guidelines  

### 7.1 Tool Provider Requirements
Tools implementing DCAP MUST:
- Generate unique, stable server identifiers
- Broadcast `semantic_discover` on first capability use with complete `connector` details (v2.5)
- Include comprehensive auth details per v2.6 specification
- Specify all required HTTP headers in `connector.headers`
- Document session initialization requirements if applicable
- Send `perf_update` messages for significant events
- Respect UDP packet size limits (prioritize critical fields)
- Sanitize arguments before including in `ctx.args` (v2.1)
- Report actual cost charged in `cost_paid` when applicable (v2.2)
- Ensure `connector.endpoint` is reachable from agent networks
- Keep authentication requirements current in `connector.auth`
- Provide valid `instructions_url` for credential acquisition (v2.6)

Tools implementing DCAP MAY:
- **Include `blockchain_registrations` for high-value scenarios** (v2.7)
- Register on ERC-8004 or similar when handling financial/healthcare/legal services
- Provide `verification_url` for human-readable verification
- Include `metadata_uri` pointing to full registration metadata

**Migration Path for Tool Providers:**
1. **Phase 1**: Start with DCAP-only (fast, free, works today)
2. **Phase 2**: Accumulate usage statistics via `proven_by`
3. **Phase 3**: Register on ERC-8004 when handling high-value scenarios
4. **Phase 4**: Include `blockchain_registrations` in DCAP broadcasts

### 7.2 Agent Consumer Requirements  
Agents implementing DCAP MUST:
- Maintain local capability knowledge base
- Handle UDP packet loss gracefully
- Implement connection retry logic for tool acquisition
- Validate tool responses before use
- Respect privacy of observed `ctx.args` data (v2.1)
- Consider cost alongside performance when selecting tools (v2.2)
- Parse and validate `connector` information before attempting connection (v2.5)
- Implement secure credential storage for auth tokens (v2.5)
- Support multiple transport types or gracefully skip unsupported tools (v2.5)
- Handle OAuth flows or prompt users with `instructions_url` (v2.6)
- Respect `headers.required` when making HTTP requests (v2.6)
- Implement session initialization per `session` specification (v2.6)
- Check credential availability before attempting tool calls (v2.6)

Agents implementing DCAP SHOULD:
- **Verify blockchain registrations for high-value scenarios** (v2.7)
- Query on-chain registries when `blockchain_registrations` present
- Fall back gracefully if blockchain verification unavailable
- Post feedback to both DCAP and blockchain registries when applicable

### 7.3 Hub Implementation Requirements
(Unchanged from v2.6 - see v2.6.md)

### 7.4 Intelligence Consumer Requirements (v2.1, updated v2.2, v2.5, v2.6, v2.7)
Systems consuming DCAP streams for intelligence (e.g., Oracle agents) SHOULD:
- Track `perf_update` sequences by `sid` for pattern detection
- Maintain statistical models of tool performance AND cost (v2.2)
- Respect privacy constraints when analyzing `ctx.args`
- Only recommend patterns that were ACTUALLY OBSERVED
- Calculate efficiency metrics incorporating both time and cost (v2.2)
- Index tools by `connector.transport` for transport-specific recommendations (v2.5)
- Track authentication requirements to inform agents of payment/access needs (v2.5)
- Classify tools by `auth.type` complexity for smart recommendations (v2.6)
- Monitor authentication success rates per auth method (v2.6)
- Identify tools that commonly fail authentication to warn agents
- **Index tools by blockchain registration status** (v2.7)
- **Correlate DCAP performance data with blockchain reputation** (v2.7)
- **Recommend blockchain-verified tools for high-value scenarios** (v2.7)

## 8. References

### 8.1 Normative References
- [RFC2119] Key words for use in RFCs
- [RFC6455] The WebSocket Protocol  
- [RFC768] User Datagram Protocol
- [RFC6749] OAuth 2.0 Authorization Framework
- [RFC7636] Proof Key for Code Exchange (PKCE)
- [MCP] Model Context Protocol Specification
- [ERC-8004] ERC-8004: Agent Registry Standard (draft)

### 8.2 Informative References
- [AutoGPT] Autonomous GPT-4 Experiment
- [LangChain] Framework for developing applications with LLMs
- [x402] x402 Micropayment Protocol
- [EIP-155] Ethereum Chain ID Specification

## 9. Changelog

### Version 2.7 (December 2025)
**Added:**
- `blockchain_registrations` array to `semantic_discover` message
- Support for ERC-8004 and other blockchain registry standards
- Section 2.3: Two-tier trust model (DCAP + ERC-8004)
- Section 5.7: Blockchain verification guidelines
- Section 6.3.5: Blockchain registration security considerations
- Examples showing ERC-8004 integration for financial and healthcare tools
- Updated UDP size management to prioritize blockchain registrations
- Updated discovery algorithm to consider blockchain registration status
- Updated intelligence consumer requirements for blockchain correlation

**Rationale:**
- ERC-8004 provides on-chain trust but lacks real-time discovery and connection automation
- DCAP provides fast discovery but lacks immutable trust guarantees
- Together: fast discovery with blockchain trust anchoring
- Enables two-tier architecture: off-chain discovery + on-chain trust
- Positions DCAP as essential infrastructure for practical agent economies
- Validates DCAP's approach by complementing major blockchain standards

**Migration from v2.6:**
- `blockchain_registrations` is optional - v2.6 tools continue to work unchanged
- Tools can add blockchain registration metadata without breaking compatibility
- Agents can ignore blockchain registrations if verification unavailable
- Backward compatible: v2.6 consumers ignore new field, still function fully

**Strategic Positioning:**
- DCAP is the off-chain discovery layer that makes blockchain-based agent trust practical
- ERC-8004 is the on-chain trust layer that provides immutable identity and reputation
- Together they solve the complete problem: fast discovery + blockchain trust

### Version 2.6 (November 2025)
(Full changelog in v2.6.md)

### Version 2.5 (October 2025)
(Full changelog in v2.6.md)

### Version 2.2 (October 2025)
(Full changelog in v2.6.md)

### Version 2.1 (October 2025)
(Full changelog in v2.6.md)

### Version 2.0 (September 2025)
- Initial public specification

## Appendix A. Example ERC-8004 Integration Implementation

```javascript
// Agent with ERC-8004 Verification (v2.7)
class DCAPAgentWithBlockchainVerification {
  constructor() {
    this.knownTools = new Map();
    this.blockchainVerifier = new ERC8004Verifier();
    this.ws = new WebSocket('ws://hub:10191', 'dcap-v2');
    this.ws.onmessage = this.handleMessage.bind(this);
  }
  
  handleMessage(event) {
    const msg = JSON.parse(event.data);
    if (msg.t === 'semantic_discover') {
      this.knownTools.set(msg.tool, msg);
      
      // Optionally verify blockchain registration in background
      if (msg.blockchain_registrations && msg.blockchain_registrations.length > 0) {
        this.verifyRegistration(msg);
      }
    }
  }
  
  async verifyRegistration(tool) {
    const registration = tool.blockchain_registrations[0];
    
    try {
      const verification = await this.blockchainVerifier.verify(registration);
      tool.blockchain_verified = verification;
    } catch (error) {
      console.warn(`Blockchain verification failed for ${tool.tool}:`, error);
      tool.blockchain_verified = { verified: false, error: error.message };
    }
  }
  
  async selectTool(capability, requireVerification = false) {
    const candidates = Array.from(this.knownTools.values())
      .filter(tool => this.matchesCapability(tool, capability));
    
    // Filter by verification requirement
    if (requireVerification) {
      candidates = candidates.filter(tool => 
        tool.blockchain_verified?.verified === true
      );
    }
    
    // Rank by success rate, cost, and verification status
    candidates.sort((a, b) => {
      const scoreA = this.calculateScore(a, requireVerification);
      const scoreB = this.calculateScore(b, requireVerification);
      return scoreB - scoreA;
    });
    
    return candidates[0];
  }
  
  calculateScore(tool, requireVerification) {
    let score = tool.proven_by?.success_rate || 0.5;
    
    // Boost score for verified tools
    if (tool.blockchain_verified?.verified) {
      score += 0.1;
      // Additional boost from on-chain reputation
      if (tool.blockchain_verified.reputation) {
        score += (tool.blockchain_verified.reputation / 1000); // Normalize
      }
    }
    
    // Penalize unverified tools if verification required
    if (requireVerification && !tool.blockchain_verified?.verified) {
      score = 0;
    }
    
    return score;
  }
  
  async invokeToolWithVerification(toolName, args, requireVerification = false) {
    const tool = this.knownTools.get(toolName);
    if (!tool) throw new Error(`Tool ${toolName} not found`);
    
    // Check verification requirement
    if (requireVerification) {
      if (!tool.blockchain_verified?.verified) {
        throw new Error(
          `Tool ${toolName} requires blockchain verification but verification failed. ` +
          `Verification URL: ${tool.blockchain_registrations?.[0]?.verification_url}`
        );
      }
    }
    
    // Proceed with normal DCAP invocation
    const result = await this.invokeTool(tool, args);
    
    // Post feedback to both DCAP and blockchain
    this.postFeedback(tool, result);
    
    return result;
  }
  
  async postFeedback(tool, result) {
    // Post to DCAP (real-time)
    this.broadcastPerfUpdate(tool, result);
    
    // Post to blockchain if registered (permanent record)
    if (tool.blockchain_registrations && tool.blockchain_registrations.length > 0) {
      await this.blockchainVerifier.submitFeedback(
        tool.blockchain_registrations[0],
        result.success ? 100 : 0
      );
    }
  }
}

// ERC-8004 Verifier
class ERC8004Verifier {
  constructor(provider) {
    this.provider = provider; // ethers.js provider
    this.registryCache = new Map();
  }
  
  async verify(registration) {
    if (registration.protocol !== 'erc-8004') {
      return { verified: false, reason: 'unsupported_protocol' };
    }
    
    const cacheKey = `${registration.registry}-${registration.agent_id}`;
    
    // Check cache
    if (this.registryCache.has(cacheKey)) {
      const cached = this.registryCache.get(cacheKey);
      if (Date.now() - cached.timestamp < 60000) { // 1 minute cache
        return cached.data;
      }
    }
    
    try {
      // Connect to registry contract
      const registry = new ethers.Contract(
        registration.registry,
        ERC8004_ABI,
        this.provider
      );
      
      // Query agent data
      const agentData = await registry.getAgent(registration.agent_id);
      
      const verification = {
        verified: agentData.isValid,
        reputation: agentData.averageScore.toNumber(),
        feedbackCount: agentData.feedbackCount.toNumber(),
        insurancePool: agentData.insurancePool,
        validationStatus: agentData.status,
        timestamp: Date.now()
      };
      
      // Cache result
      this.registryCache.set(cacheKey, {
        data: verification,
        timestamp: Date.now()
      });
      
      return verification;
    } catch (error) {
      return {
        verified: false,
        error: error.message,
        reason: 'verification_failed'
      };
    }
  }
  
  async submitFeedback(registration, score) {
    try {
      const registry = new ethers.Contract(
        registration.registry,
        ERC8004_ABI,
        this.provider.getSigner()
      );
      
      const tx = await registry.submitFeedback(
        registration.agent_id,
        score,
        { gasLimit: 100000 }
      );
      
      await tx.wait();
      return { success: true, txHash: tx.hash };
    } catch (error) {
      console.error('Failed to submit blockchain feedback:', error);
      return { success: false, error: error.message };
    }
  }
}

// ERC-8004 ABI (simplified)
const ERC8004_ABI = [
  "function getAgent(uint256 agentId) view returns (bool isValid, uint256 averageScore, uint256 feedbackCount, address insurancePool, string status)",
  "function submitFeedback(uint256 agentId, uint256 score) returns (bool)"
];

// Usage Example
const agent = new DCAPAgentWithBlockchainVerification();

// Wait for discovery
await new Promise(resolve => setTimeout(resolve, 5000));

// Select tool for high-value scenario (requires verification)
try {
  const financialTool = await agent.selectTool(
    'investment advice',
    true  // requireVerification - only use blockchain-verified tools
  );
  
  const advice = await agent.invokeToolWithVerification(
    financialTool.tool,
    { portfolio: {...} },
    true  // requireVerification
  );
  
  console.log('Investment advice:', advice);
} catch (error) {
  if (error.message.includes('verification')) {
    console.error('Cannot use unverified tool for financial advice');
  } else {
    throw error;
  }
}
```

## Appendix B. Two-Tier Architecture Benefits

### B.1 Why DCAP + ERC-8004 Works

**DCAP Solves ERC-8004's Discovery Problem:**
- ERC-8004 registration file contains minimal connection info (just a URL)
- DCAP provides full OAuth2 flows, headers, session initialization
- Agents finding ERC-8004 registration still need DCAP to connect

**ERC-8004 Solves DCAP's Trust Problem:**
- DCAP provides statistical trust (proven_by) but no legal guarantees
- ERC-8004 provides immutable identity and reputation anchoring
- Together: fast discovery with blockchain trust

**Classic Blockchain Pattern:**
- On-chain: What needs to be trustless (identity, reputation)
- Off-chain: What needs to be fast/private/cheap (discovery, connection, metrics)

### B.2 Developer Journey

**Phase 1: Development (DCAP-only)**
- Broadcast tool via DCAP (free, instant)
- Agents discover in milliseconds
- Accumulate usage statistics
- No blockchain costs

**Phase 2: Production (DCAP + Optional Verification)**
- Add API keys/OAuth2
- Deploy to network
- Continue using DCAP for discovery
- Optionally verify via blockchain

**Phase 3: High-Value (DCAP + ERC-8004)**
- Register on ERC-8004 (pay gas, get identity)
- Include `blockchain_registrations` in DCAP broadcasts
- Agents discover via DCAP, verify via ERC-8004
- Dual-layer trust: statistical + cryptographic

### B.3 Market Positioning

**One-Liner:**
"DCAP is the off-chain discovery and performance layer that makes blockchain-based agent trust practical. While ERC-8004 provides immutable identity and reputation on-chain, DCAP provides real-time discovery, connection automation, and performance telemetry off-chain. Together, they enable the agent economy."

**Key Points:**
- Not competing with ERC-8004 - complementing it
- DCAP solves 80% use case (fast, free, practical)
- ERC-8004 solves 20% use case (high-value, trust-critical)
- Together: complete solution

## Authors' Addresses

Martin Maurer  
Email: empeamtk@googlemail.com

